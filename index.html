<!-- Working Version 2.2.6.5. DeepSeek JS replacement. Photo function repaired. Has Data Import issue. -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoLens - Field Observation Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    /* CSS Reset & Base Styles - Enhanced for cross-browser compatibility */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -moz-tap-highlight-color: transparent;
        -ms-tap-highlight-color: transparent;
    }

    /* Add focus styles for accessibility */
    *:focus {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
    }

    /* Improve focus styles for buttons */
    .btn:focus {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
        box-shadow: 0 0 0 4px rgba(46, 139, 87, 0.2);
    }

    /* Add focus styles for form inputs */
    .form-input:focus,
    .form-select:focus,
    .form-textarea:focus {
        outline: 2px solid var(--primary);
        outline-offset: 2px;
    }

    /* Light mode variables (default) */
    :root {
        --primary: #2e8b57;
        --primary-dark: #1e6b47;
        --primary-light: #e8f5e9;
        --secondary: #3498db;
        --secondary-dark: #2980b9;
        --accent: #f39c12;
        --dark: #2c3e50;
        --dark-light: #34495e;
        --light: #f8f9fa;
        --light-gray: #ecf0f1;
        --medium-gray: #bdc3c7;
        --danger: #e74c3c;
        --success: #27ae60;
        --warning: #f39c12;
        --info: #3498db;
        --border-radius: 12px;
        --border-radius-sm: 8px;
        --border-radius-lg: 16px;
        --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
        --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        --transition-fast: all 0.2s ease;
        
        /* Light mode color variables */
        --bg-primary: #f8f9fa;
        --bg-secondary: white;
        --text-primary: #333;
        --text-secondary: #2c3e50;
        --border-color: #ecf0f1;
        --shadow-color: rgba(0, 0, 0, 0.08);
    }

    /* Dark mode variables */
    body.dark-mode {
        --bg-primary: #1a1a1a;
        --bg-secondary: #2d2d2d;
        --text-primary: #e0e0e0;
        --text-secondary: #b0b0b0;
        --border-color: #404040;
        --shadow-color: rgba(0, 0, 0, 0.3);
        --light: #2d2d2d;
        --light-gray: #404040;
        --medium-gray: #666;
    }

    /* High contrast mode support */
    @media (prefers-contrast: high) {
        :root {
            --primary: #006400;
            --secondary: #0000ff;
            --danger: #8b0000;
        }
    }

    body {
        font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        line-height: 1.6;
        color: var(--text-primary);
        background: var(--bg-primary);
        max-width: 100vw;
        min-height: 100vh;
        overflow-x: hidden;
        transition: background-color 0.3s ease, color 0.3s ease;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    /* Skip link for accessibility */
    .skip-link {
        position: absolute;
        top: -40px;
        left: 0;
        background: var(--primary);
        color: white;
        padding: 8px 16px;
        text-decoration: none;
        border-radius: var(--border-radius-sm);
        z-index: 1001;
    }

    .skip-link:focus {
        top: 10px;
    }

    /* Header & Navigation */
    .header {
        background: linear-gradient(135deg, var(--dark) 0%, var(--dark-light) 100%);
        color: white;
        padding: 1rem 1.5rem;
        position: sticky;
        top: 0;
        z-index: 1000;
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        background-color: rgba(44, 62, 80, 0.95);
        -webkit-backdrop-filter: blur(10px);
    }

    .app-title-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-bottom: 1rem;
    }

    .app-icon {
        font-size: 1.8rem;
        color: var(--primary-light);
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
    }

    .app-title {
        font-size: 1.8rem;
        font-weight: 700;
        text-align: center;
        background: linear-gradient(90deg, #fff, var(--primary-light));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        letter-spacing: -0.5px;
    }

    .app-subtitle {
        font-size: 0.9rem;
        text-align: center;
        color: rgba(255, 255, 255, 0.8);
        margin-top: -5px;
        font-weight: 400;
    }

    .nav-tabs {
        display: flex;
        gap: 0.5rem;
        justify-content: center;
        background: rgba(0, 0, 0, 0.1);
        padding: 0.5rem;
        border-radius: var(--border-radius);
        max-width: 600px;
        margin: 0 auto;
    }

    .tab-btn {
        padding: 0.7rem 1.5rem;
        background: transparent;
        border: none;
        border-radius: var(--border-radius);
        color: rgba(255, 255, 255, 0.8);
        font-size: 0.95rem;
        font-weight: 500;
        cursor: pointer;
        transition: var(--transition-fast);
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        position: relative;
        overflow: hidden;
    }

    .tab-btn.active {
        background: rgba(255, 255, 255, 0.15);
        color: white;
        font-weight: 600;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .tab-btn.active::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 60%;
        height: 3px;
        background: var(--primary);
        border-radius: 3px;
    }

    .tab-btn:hover:not(.active) {
        background: rgba(255, 255, 255, 0.05);
        color: white;
        transform: translateY(-1px);
    }

    /* Main Content */
    .main-content {
        max-width: 900px;
        margin: 0 auto;
        padding: 1.5rem 1rem 3rem;
    }

    .tab-panel {
        display: none;
        animation: fadeIn 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    .tab-panel.active {
        display: block;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(15px); }
        to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
        from { opacity: 0; transform: translateX(-10px); }
        to { opacity: 1; transform: translateX(0); }
    }

    /* Use My Location Styles */
    #use-my-location .loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top: 2px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        vertical-align: middle;
        margin-right: 5px;
    }

    .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    /* Form Styles */
    .form-section {
        background: var(--bg-secondary);
        border-radius: var(--border-radius-lg);
        padding: 2rem;
        margin-bottom: 1.5rem;
        box-shadow: var(--shadow);
        border: 1px solid var(--border-color);
        transition: var(--transition);
    }

    .form-section:hover {
        box-shadow: var(--shadow-lg);
    }

    .form-title {
        font-size: 1.4rem;
        margin-bottom: 1.5rem;
        color: var(--dark);
        padding-bottom: 1rem;
        border-bottom: 2px solid var(--light-gray);
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 600;
    }

    body.dark-mode .form-title {
        color: var(--text-primary);
    }

    .form-title i {
        color: var(--primary);
    }

    .form-group {
        margin-bottom: 1.8rem;
        animation: slideIn 0.3s ease-out;
    }

    .form-label {
        display: block;
        font-weight: 600;
        margin-bottom: 0.6rem;
        color: var(--dark-light);
        font-size: 0.95rem;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    body.dark-mode .form-label {
        color: var(--text-primary);
    }

    .form-label.required::after {
        content: " *";
        color: var(--danger);
    }

    .form-input,
    .form-select,
    .form-textarea {
        width: 100%;
        padding: 0.9rem 1rem;
        border: 2px solid var(--border-color);
        border-radius: var(--border-radius-sm);
        font-size: 1rem;
        transition: var(--transition-fast);
        background: var(--bg-secondary);
        color: var(--text-primary);
        font-family: inherit;
    }

    .form-input:focus,
    .form-select:focus,
    .form-textarea:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(46, 139, 87, 0.15);
    }

    .form-textarea {
        min-height: 120px;
        resize: vertical;
        line-height: 1.5;
    }

    /* Improved form validation styles */
    .form-input:invalid,
    .form-select:invalid,
    .form-textarea:invalid {
        border-color: var(--danger);
    }

    .form-input:invalid:focus,
    .form-select:invalid:focus,
    .form-textarea:invalid:focus {
        box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.15);
    }

    .form-row {
        display: flex;
        gap: 1.5rem;
        margin-bottom: 1.8rem;
    }

    .form-col {
        flex: 1;
    }

    /* Map Container */
    #map-container {
        height: 320px;
        margin-top: 1rem;
        border-radius: var(--border-radius-sm);
        overflow: hidden;
        border: 2px solid var(--light-gray);
        box-shadow: var(--shadow-sm);
        display: none;
        position: relative;
    }

    #map {
        height: 100%;
        width: 100%;
    }

    .map-controls {
        display: flex;
        gap: 0.75rem;
        margin-top: 1rem;
        flex-wrap: wrap;
    }

    /* Button Styles */
    .btn {
        padding: 0.85rem 1.75rem;
        border: none;
        border-radius: var(--border-radius);
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: var(--transition);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        position: relative;
        overflow: hidden;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .btn::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 5px;
        height: 5px;
        background: rgba(255, 255, 255, 0.5);
        opacity: 0;
        border-radius: 100%;
        transform: scale(1, 1) translate(-50%);
        transform-origin: 50% 50%;
    }

    .btn:focus:not(:active)::after {
        animation: ripple 1s ease-out;
    }

    @keyframes ripple {
        0% {
            transform: scale(0, 0);
            opacity: 0.5;
        }
        100% {
            transform: scale(40, 40);
            opacity: 0;
        }
    }

    .btn-primary {
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(46, 139, 87, 0.25);
    }

    .btn-primary:hover {
        background: linear-gradient(135deg, var(--primary-dark) 0%, #165a36 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(46, 139, 87, 0.35);
    }

    .btn-secondary {
        background: linear-gradient(135deg, var(--secondary) 0%, var(--secondary-dark) 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.25);
    }

    .btn-secondary:hover {
        background: linear-gradient(135deg, var(--secondary-dark) 0%, #21618c 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(52, 152, 219, 0.35);
    }

    .btn-outline {
        background: var(--bg-secondary);
        color: var(--primary);
        border: 2px solid var(--primary);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
    }

    body.dark-mode .btn-outline {
        background: var(--bg-secondary);
        color: var(--primary-light);
        border-color: var(--primary);
    }

    .btn-outline:hover {
        background: var(--primary-light);
        color: var(--primary-dark);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    body.dark-mode .btn-outline:hover {
        background: var(--primary);
        color: white;
    }

    .btn-danger {
        background: linear-gradient(135deg, var(--danger) 0%, #c0392b 100%);
        color: white;
        box-shadow: 0 4px 12px rgba(231, 76, 60, 0.25);
    }

    .btn-danger:hover {
        background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(231, 76, 60, 0.35);
    }

    .btn-small {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
        border-radius: var(--border-radius-sm);
    }

    .btn-block {
        width: 100%;
        padding: 1rem;
        font-size: 1.05rem;
    }

    .btn-group {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.5rem;
        flex-wrap: wrap;
    }

    /* Photo Upload */
    .photo-container {
        margin-top: 1rem;
    }

    .photo-preview-container {
        position: relative;
        display: inline-block;
        margin-top: 1rem;
    }

    .photo-preview {
        max-width: 250px;
        max-height: 250px;
        border-radius: var(--border-radius);
        border: 2px solid var(--light-gray);
        display: none;
        box-shadow: var(--shadow);
        transition: var(--transition);
        -webkit-user-drag: none;
        -khtml-user-drag: none;
        -moz-user-drag: none;
        -o-user-drag: none;
        user-drag: none;
    }

    .photo-preview:hover {
        transform: scale(1.02);
        box-shadow: var(--shadow-lg);
    }

    .photo-remove {
        position: absolute;
        top: -10px;
        right: -10px;
        background: var(--danger);
        color: white;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 2px solid var(--bg-secondary);
        box-shadow: var(--shadow);
        font-size: 0.9rem;
        z-index: 10;
    }

    /* Checkbox/Radio Groups */
    .checkbox-group,
    .radio-group {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-top: 0.75rem;
    }

    .checkbox-item,
    .radio-item {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        padding: 0.5rem 1rem;
        background: var(--light);
        border-radius: var(--border-radius-sm);
        transition: var(--transition-fast);
        cursor: pointer;
    }

    body.dark-mode .checkbox-item,
    body.dark-mode .radio-item {
        background: var(--light);
        color: var(--text-primary);
    }

    .checkbox-item:hover,
    .radio-item:hover {
        background: var(--primary-light);
        transform: translateY(-2px);
    }

    body.dark-mode .checkbox-item:hover,
    body.dark-mode .radio-item:hover {
        background: var(--primary);
    }

    .checkbox-item input[type="checkbox"],
    .radio-item input[type="radio"] {
        width: auto;
        accent-color: var(--primary);
    }

    /* DateTime Input */
    .datetime-inputs {
        display: flex;
        gap: 1rem;
        align-items: flex-end;
    }

    .datetime-inputs input {
        flex: 1;
    }

    .datetime-now-btn {
        white-space: nowrap;
        height: 100%;
        padding: 0.9rem 1.5rem;
    }

    /* Logbook Styles */
    .logbook-entries {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
    }

    .log-entry {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 1.5rem;
        box-shadow: var(--shadow-sm);
        cursor: pointer;
        transition: var(--transition);
        border-left: 4px solid var(--primary);
        position: relative;
        overflow: hidden;
    }

    .log-entry:hover {
        transform: translateY(-4px);
        box-shadow: var(--shadow-lg);
    }

    .log-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 0.75rem;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .log-id {
        font-family: 'Courier New', monospace;
        color: var(--medium-gray);
        font-size: 0.85rem;
        background: var(--light);
        padding: 0.25rem 0.75rem;
        border-radius: 20px;
        font-weight: 500;
    }

    .log-date {
        color: var(--medium-gray);
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .log-species {
        font-weight: 700;
        font-size: 1.2rem;
        color: var(--dark);
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    body.dark-mode .log-species {
        color: var(--text-primary);
    }

    .log-species::before {
        content: "ü¶ã";
        font-size: 1.1rem;
    }

    .log-location {
        color: var(--dark-light);
        font-size: 0.95rem;
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 0.5rem;
    }

    .log-location::before {
        content: "üìç";
        font-size: 0.9rem;
    }

    .log-details {
        margin-top: 1.2rem;
        padding-top: 1.2rem;
        border-top: 1px solid var(--light-gray);
        display: none;
        animation: fadeIn 0.3s ease;
    }

    .log-details.show {
        display: block;
    }

    .log-actions {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.2rem;
    }

    /* Export Panel */
    .export-options {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 1.8rem;
        margin-bottom: 1.5rem;
        box-shadow: var(--shadow);
    }

    .export-option-group {
        margin-bottom: 2rem;
    }

    .export-option {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
        padding: 0.75rem 1rem;
        background: var(--light);
        border-radius: var(--border-radius-sm);
        transition: var(--transition-fast);
    }

    body.dark-mode .export-option {
        background: var(--light);
        color: var(--text-primary);
    }

    .export-option:hover {
        background: var(--primary-light);
    }

    .export-option input[type="radio"] {
        width: auto;
        accent-color: var(--primary);
    }

    .date-range {
        display: flex;
        gap: 1.5rem;
        margin-top: 1rem;
    }

    .date-input {
        flex: 1;
    }

    /* Import Section */
    .import-section {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 1.8rem;
        margin-bottom: 1.5rem;
        border: 2px dashed var(--secondary);
        background: linear-gradient(135deg, var(--light) 0%, var(--light-gray) 100%);
        box-shadow: var(--shadow);
    }

    body.dark-mode .import-section {
        background: linear-gradient(135deg, var(--light) 0%, var(--dark-light) 100%);
    }

    .import-options {
        margin-top: 1rem;
    }

    .import-note {
        font-size: 0.9rem;
        color: var(--dark-light);
        margin-top: 1rem;
        padding: 1rem;
        background: var(--light);
        border-radius: var(--border-radius-sm);
        border-left: 4px solid var(--secondary);
        line-height: 1.5;
    }

    body.dark-mode .import-note {
        background: var(--light);
        color: var(--text-primary);
    }

    /* Import Mode Selection */
    .import-mode {
        display: flex;
        gap: 1.5rem;
        margin-top: 1.2rem;
        flex-wrap: wrap;
    }

    .import-mode-option {
        flex: 1;
        min-width: 200px;
    }

    /* CSV Preview & Validation */
    .csv-preview-section {
        margin-top: 1.5rem;
        display: none;
        animation: fadeIn 0.4s ease;
    }

    .csv-preview-table {
        width: 100%;
        border-collapse: collapse;
        margin: 1rem 0;
        font-size: 0.9rem;
        box-shadow: var(--shadow-sm);
        border-radius: var(--border-radius-sm);
        overflow: hidden;
    }

    .csv-preview-table th,
    .csv-preview-table td {
        padding: 0.75rem;
        border: 1px solid var(--light-gray);
        text-align: left;
    }

    .csv-preview-table th {
        background: linear-gradient(135deg, var(--dark) 0%, var(--dark-light) 100%);
        color: white;
        font-weight: 600;
        position: sticky;
        top: 0;
    }

    .csv-preview-table .error-row {
        background-color: #f8d7da;
    }

    .csv-preview-table .warning-row {
        background-color: #fff3cd;
    }

    .validation-summary {
        padding: 1.2rem;
        border-radius: var(--border-radius);
        margin: 1rem 0;
    }

    .validation-errors {
        margin-top: 0.75rem;
    }

    .validation-error {
        padding: 0.75rem;
        background: #f8d7da;
        border-radius: var(--border-radius-sm);
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
        border-left: 4px solid var(--danger);
    }

    .validation-warning {
        padding: 0.75rem;
        background: #fff3cd;
        border-radius: var(--border-radius-sm);
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
        border-left: 4px solid var(--warning);
    }

    .validation-stats {
        display: flex;
        gap: 1.5rem;
        margin: 1.5rem 0;
        flex-wrap: wrap;
    }

    .stat-item {
        padding: 0.75rem 1.25rem;
        border-radius: var(--border-radius);
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
        box-shadow: var(--shadow-sm);
    }

    .stat-valid {
        background: #d5edda;
        color: #155724;
    }

    .stat-invalid {
        background: #f8d7da;
        color: #721c24;
    }

    .stat-warning {
        background: #fff3cd;
        color: #856404;
    }

    .stat-info {
        background: #d1ecf1;
        color: #0c5460;
    }

    /* Status Messages */
    .status-message {
        padding: 1.2rem;
        border-radius: var(--border-radius);
        margin: 1.5rem 0;
        text-align: center;
        font-weight: 500;
        animation: fadeIn 0.3s ease;
        box-shadow: var(--shadow-sm);
    }

    .status-success {
        background: #d5edda;
        color: #155724;
        border: 1px solid #c3e6cb;
        border-left: 4px solid var(--success);
    }

    .status-error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
        border-left: 4px solid var(--danger);
    }

    .status-info {
        background: #d1ecf1;
        color: #0c5460;
        border: 1px solid #bee5eb;
        border-left: 4px solid var(--info);
    }

    .status-warning {
        background: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
        border-left: 4px solid var(--warning);
    }

    body.dark-mode .status-message {
        background: var(--bg-secondary);
    }

    /* Loading Indicator */
    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* PDF Generation Status */
    .pdf-status {
        background: #e8f4fc;
        border: 1px solid #b6e0fe;
        border-radius: var(--border-radius);
        padding: 1.5rem;
        margin: 1.5rem 0;
        display: none;
        box-shadow: var(--shadow-sm);
    }

    .pdf-status progress {
        width: 100%;
        height: 12px;
        margin: 0.75rem 0;
        border-radius: 6px;
        overflow: hidden;
        -webkit-appearance: none;
        appearance: none;
    }

    .pdf-status progress::-webkit-progress-bar {
        background-color: #f0f0f0;
        border-radius: 6px;
    }

    .pdf-status progress::-webkit-progress-value {
        background: linear-gradient(90deg, var(--primary), var(--secondary));
        border-radius: 6px;
    }

    .pdf-status progress::-moz-progress-bar {
        background: linear-gradient(90deg, var(--primary), var(--secondary));
        border-radius: 6px;
    }

    /* Tooltip */
    .tooltip {
        position: relative;
        display: inline-block;
    }

    .tooltip .tooltip-text {
        visibility: hidden;
        width: 220px;
        background-color: var(--dark);
        color: white;
        text-align: center;
        border-radius: var(--border-radius-sm);
        padding: 0.75rem;
        position: absolute;
        z-index: 100;
        bottom: 125%;
        left: 50%;
        margin-left: -110px;
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.85rem;
        font-weight: normal;
        box-shadow: var(--shadow);
    }

    .tooltip:hover .tooltip-text {
        visibility: visible;
        opacity: 1;
    }

    /* Batch Selection */
    .batch-selection {
        margin: 1.5rem 0;
        padding: 1.5rem;
        background: var(--light);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-sm);
    }

    .batch-checkboxes {
        max-height: 250px;
        overflow-y: auto;
        margin: 1rem 0;
        padding: 1rem;
        background: var(--bg-secondary);
        border: 1px solid var(--light-gray);
        border-radius: var(--border-radius-sm);
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }

    .batch-checkbox-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem 0;
        transition: var(--transition-fast);
    }

    .batch-checkbox-item:hover {
        background: var(--primary-light);
        padding-left: 0.5rem;
        border-radius: 4px;
    }

    /* Mini Map Preview */
    .mini-map-preview {
        height: 180px;
        width: 100%;
        border-radius: var(--border-radius-sm);
        margin: 0.75rem 0;
        border: 2px solid var(--light-gray);
        box-shadow: var(--shadow-sm);
    }

    .coordinate-validation {
        font-size: 0.85rem;
        margin-top: 0.5rem;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .coordinate-valid {
        color: var(--success);
    }

    .coordinate-invalid {
        color: var(--danger);
    }

    /* Empty States */
    .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        color: var(--medium-gray);
    }

    .empty-state i {
        font-size: 3rem;
        margin-bottom: 1rem;
        color: var(--light-gray);
    }

    body.dark-mode .empty-state i {
        color: var(--medium-gray);
    }

    /* Card Enhancements */
    .card {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 1.5rem;
        box-shadow: var(--shadow);
        margin-bottom: 1.5rem;
        transition: var(--transition);
        border: 1px solid var(--border-color);
    }

    .card:hover {
        box-shadow: var(--shadow-lg);
    }

    /* Mobile Optimizations */
    @media (max-width: 768px) {
        .main-content {
            padding: 1rem 0.75rem 2rem;
        }
        
        .form-section {
            padding: 1.5rem 1rem;
        }
        
        .header {
            padding: 0.75rem 1rem;
        }
        
        .app-title {
            font-size: 1.5rem;
        }
        
        .app-subtitle {
            font-size: 0.8rem;
        }
        
        .tab-btn {
            padding: 0.6rem;
            font-size: 0.85rem;
        }
        
        .tab-btn i {
            font-size: 1rem;
        }
        
        .form-row {
            flex-direction: column;
            gap: 1rem;
        }
        
        .datetime-inputs {
            flex-direction: column;
            gap: 0.75rem;
            align-items: stretch;
        }
        
        .datetime-inputs input {
            width: 100%;
        }
        
        .datetime-now-btn {
            align-self: flex-start;
            width: auto;
        }
        
        .date-range {
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .log-actions {
            flex-direction: column;
        }
        
        .map-controls {
            flex-direction: column;
        }
        
        .btn {
            padding: 0.75rem 1.25rem;
        }
        
        .btn-block {
            padding: 0.9rem;
        }
        
        .btn-group {
            flex-direction: column;
        }
        
        .import-mode {
            flex-direction: column;
        }
        
        .import-mode-option {
            min-width: 100%;
        }
        
        .validation-stats {
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .form-title {
            font-size: 1.2rem;
        }
        
        #map-container {
            height: 250px;
        }
        
        .photo-preview {
            max-width: 100%;
        }
    }

    @media (max-width: 480px) {
        .nav-tabs {
            flex-direction: column;
        }
        
        .tab-btn {
            justify-content: flex-start;
            padding-left: 1rem;
        }
        
        .checkbox-group,
        .radio-group {
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .checkbox-item,
        .radio-item {
            width: 100%;
        }
    }

/* Ensure photo remove button is always clickable */
.photo-preview-container:hover .photo-remove {
    display: flex !important;
}

/* Make photo container more responsive */
.photo-container {
    position: relative;
    min-height: 100px;
}

.photo-preview {
    cursor: pointer;
    transition: all 0.3s ease;
}

.photo-preview:hover {
    transform: scale(1.03);
    box-shadow: 0 8px 25px rgba(0,0,0,0.2);
}

/* Ensure remove button is accessible */
.photo-remove:focus {
    outline: 2px solid var(--danger);
    outline-offset: 2px;
}

/* Improve photo info display */
#photo-info {
    background: var(--light);
    padding: 0.5rem;
    border-radius: var(--border-radius-sm);
    border: 1px solid var(--border-color);
    margin-top: 0.5rem;
    font-size: 0.85rem;
}

#photo-info span {
    display: inline-block;
    margin-right: 1rem;
}

#photo-info i {
    margin-right: 0.25rem;
    opacity: 0.7;
}

    /* Print Styles */
    @media print {
        .header,
        .tab-panel:not(.active),
        .btn,
        .map-controls,
        .photo-remove,
        .dark-mode-btn,
        .fab {
            display: none !important;
        }
        
        .form-section,
        .log-entry,
        .export-options {
            box-shadow: none;
            border: 1px solid #ddd;
            break-inside: avoid;
        }
        
        body {
            background: white;
        }
        
        .main-content {
            max-width: 100%;
            padding: 0;
        }
        
        * {
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
            color-adjust: exact;
        }
    }

    /* Custom Scrollbar - Enhanced for Firefox */
    * {
        scrollbar-width: thin;
        scrollbar-color: var(--primary) #f1f1f1;
    }

    ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }

    ::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb {
        background: var(--primary);
        border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: var(--primary-dark);
    }

    body.dark-mode ::-webkit-scrollbar-track {
        background: var(--light-gray);
    }
    
    body.dark-mode ::-webkit-scrollbar-thumb {
        background: var(--primary);
    }

    /* Floating Action Button for Mobile */
    .fab {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        width: 60px;
        height: 60px;
        background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        color: white;
        border-radius: 50%;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        box-shadow: var(--shadow-lg);
        z-index: 100;
        cursor: pointer;
        transition: var(--transition);
        border: none;
        -webkit-tap-highlight-color: transparent;
    }

    .fab:hover {
        transform: scale(1.1);
    }

    @media (max-width: 768px) {
        .fab {
            display: flex;
        }
    }

    /* Divider */
    .divider {
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--light-gray), transparent);
        margin: 1.5rem 0;
        border: none;
    }

    /* Badge */
    .badge {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        font-size: 0.75rem;
        font-weight: 600;
        border-radius: 20px;
        background: var(--primary-light);
        color: var(--primary-dark);
    }

    /* Animation for new entries */
    @keyframes highlight {
        0% { background-color: rgba(46, 139, 87, 0.3); }
        100% { background-color: var(--bg-secondary); }
    }

    .new-entry {
        animation: highlight 2s ease;
    }

    /* Dark Mode Toggle Button */
    .dark-mode-btn {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: transparent;
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        transition: var(--transition);
        z-index: 1001;
        -webkit-tap-highlight-color: transparent;
    }
    
    .dark-mode-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        transform: rotate(30deg);
    }
    
    body.dark-mode .dark-mode-btn {
        border-color: rgba(255, 255, 255, 0.3);
        color: var(--accent);
    }
    
    body.dark-mode .dark-mode-btn:hover {
        background: rgba(255, 255, 255, 0.1);
    }
    
    /* Tab buttons dark mode */
    body.dark-mode .tab-btn {
        color: rgba(255, 255, 255, 0.9);
    }
    
    body.dark-mode .tab-btn.active {
        background: rgba(255, 255, 255, 0.2);
    }
    
    body.dark-mode .tab-btn:hover:not(.active) {
        background: rgba(255, 255, 255, 0.1);
    }
    
    /* Update map controls for dark mode */
    .leaflet-container {
        background: var(--bg-secondary) !important;
    }
    
    body.dark-mode .leaflet-tile {
        filter: invert(1) hue-rotate(180deg) brightness(0.95) contrast(0.9);
    }
    
    body.dark-mode .leaflet-control {
        background-color: var(--bg-secondary) !important;
        border-color: var(--border-color) !important;
    }
    
    body.dark-mode .leaflet-control a {
        background-color: var(--bg-secondary) !important;
        color: var(--text-primary) !important;
        border-color: var(--border-color) !important;
    }
    
    body.dark-mode .leaflet-popup-content-wrapper {
        background-color: var(--bg-secondary) !important;
        color: var(--text-primary) !important;
    }
    
    body.dark-mode .leaflet-popup-tip {
        background-color: var(--bg-secondary) !important;
    }

    /* Screen reader only class */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }

    /* Focus visible polyfill for better accessibility */
    .js-focus-visible :focus:not(.focus-visible) {
        outline: none;
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
            scroll-behavior: auto !important;
        }
    }

    /* Improved fieldset and legend for accessibility */
    fieldset {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius-sm);
        padding: 1rem;
        margin-bottom: 1.5rem;
    }

    legend {
        font-weight: 600;
        padding: 0 0.5rem;
        color: var(--dark);
    }

    body.dark-mode legend {
        color: var(--text-primary);
    }

/* Fix photo remove button z-index */
.photo-remove {
    z-index: 1000 !important;
    pointer-events: auto !important;
}
</style>
</head>
<body>
    <!-- Skip link for keyboard users -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <div class="header">
        <div class="app-title-container">
            <div class="app-icon" aria-hidden="true">üî¨</div>
            <div>
                <h1 class="app-title">EcoLens</h1>
                <div class="app-subtitle">Field Observation & Data Collection Tool</div>
            </div>
        </div>

        <button id="dark-mode-toggle" class="dark-mode-btn" title="Toggle dark mode" aria-label="Toggle dark mode">
            <i class="fas fa-moon" aria-hidden="true"></i>
        </button>

        <div class="nav-tabs" role="tablist">
            <button class="tab-btn active" data-tab="record" role="tab" aria-selected="true" aria-controls="record-panel" id="tab-record">
                <i class="fas fa-plus-circle" aria-hidden="true"></i> Record
            </button>
            <button class="tab-btn" data-tab="logbook" role="tab" aria-selected="false" aria-controls="logbook-panel" id="tab-logbook">
                <i class="fas fa-book" aria-hidden="true"></i> Logbook
            </button>
            <button class="tab-btn" data-tab="export" role="tab" aria-selected="false" aria-controls="export-panel" id="tab-export">
                <i class="fas fa-file-export" aria-hidden="true"></i> Export
            </button>
        </div>
    </div>

    <div class="main-content" id="main-content">
        <!-- Record Panel -->
        <div id="record-panel" class="tab-panel active" role="tabpanel" aria-labelledby="tab-record" tabindex="0">
            <div class="form-section">
                <h2 class="form-title">
                    <i class="fas fa-feather-alt" aria-hidden="true"></i> New Field Observation
                </h2>
                
                <!-- Date & Time -->
                <div class="form-group">
                    <label class="form-label required" for="observation-date">
                        <i class="far fa-calendar-alt" aria-hidden="true"></i> Observation Date & Time
                    </label>
                    <div class="datetime-inputs">
                        <div class="form-col">
                            <input type="date" id="observation-date" class="form-input" required 
                                   aria-label="Observation date" aria-required="true">
                        </div>
                        <div class="form-col">
                            <input type="time" id="observation-time" class="form-input" required 
                                   aria-label="Observation time" aria-required="true">
                        </div>
                        <button type="button" id="set-now" class="btn btn-outline datetime-now-btn" aria-label="Set to current time">
                            <i class="far fa-clock" aria-hidden="true"></i> Now
                        </button>
                    </div>
                </div>

                <!-- Observer Name -->
                <div class="form-group">
                    <label class="form-label required" for="observer-name">
                        <i class="fas fa-user" aria-hidden="true"></i> Observer Name
                    </label>
                    <input type="text" id="observer-name" class="form-input" 
                           placeholder="Enter observer's full name" required 
                           aria-label="Observer name" aria-required="true"
                           autocomplete="name">
                </div>

                <!-- Species Information -->
                <div class="form-row">
                    <div class="form-col">
                        <label class="form-label required" for="scientific-name">
                            <i class="fas fa-dna" aria-hidden="true"></i> Scientific Name
                        </label>
                        <input type="text" id="scientific-name" class="form-input" 
                               placeholder="Genus species" required 
                               aria-label="Scientific name" aria-required="true">
                    </div>
                    <div class="form-col">
                        <label class="form-label" for="common-name">
                            <i class="fas fa-tag" aria-hidden="true"></i> Common Name
                        </label>
                        <input type="text" id="common-name" class="form-input" 
                               placeholder="Local/common name" aria-label="Common name">
                    </div>
                </div>

                <!-- Location -->
                <div class="form-group">
                    <label class="form-label required" for="location">
                        <i class="fas fa-map-marker-alt" aria-hidden="true"></i> Location
                    </label>
                    <input type="text" id="location" class="form-input" 
                           placeholder="Describe the location or address" required 
                           aria-label="Location description" aria-required="true">
                    <div class="map-controls">
                        <button type="button" id="toggle-map" class="btn btn-outline" aria-label="Toggle map display">
                            <i class="fas fa-map" aria-hidden="true"></i> <span id="map-toggle-text">Show Map</span>
                        </button>
                        <button type="button" id="use-my-location" class="btn btn-outline" aria-label="Use current location">
                            <i class="fas fa-location-arrow" aria-hidden="true"></i> Use My Location
                        </button>
                    </div>
                    <div id="map-container">
                        <div id="map" aria-label="Map for selecting location"></div>
                    </div>
                    <div id="location-status" class="status-message" style="display: none; margin-top: 0.5rem;"></div>
                </div>

                <!-- Habitat & Observation Type -->
                <div class="form-row">
                    <div class="form-col">
                        <label class="form-label required" for="habitat">
                            <i class="fas fa-tree" aria-hidden="true"></i> Habitat Type
                        </label>
                        <select id="habitat" class="form-select" required 
                                aria-label="Habitat type" aria-required="true">
                            <option value="">Select habitat type</option>
                            <option value="forest">üå≥ Forest</option>
                            <option value="wetland">üíß Wetland</option>
                            <option value="grassland">üåæ Grassland</option>
                            <option value="coastal">üèñÔ∏è Coastal</option>
                            <option value="urban">üèôÔ∏è Urban</option>
                            <option value="agricultural">üöú Agricultural</option>
                            <option value="alpine">‚õ∞Ô∏è Alpine</option>
                            <option value="riverine">üåä Riverine</option>
                            <option value="desert">üèúÔ∏è Desert</option>
                            <option value="other">üîç Other</option>
                        </select>
                    </div>
                    <div class="form-col">
                        <label class="form-label required" for="observation-type">
                            <i class="fas fa-binoculars" aria-hidden="true"></i> Observation Type
                        </label>
                        <select id="observation-type" class="form-select" required 
                                aria-label="Observation type" aria-required="true">
                            <option value="">Select type</option>
                            <option value="direct">üëÅÔ∏è Direct sighting</option>
                            <option value="scat">üí© Scat/droppings</option>
                            <option value="track">üë£ Track/footprint</option>
                            <option value="call">üéµ Call/sound</option>
                            <option value="nest">üè† Nest/den</option>
                            <option value="roadkill">üöó Roadkill</option>
                            <option value="feather">ü™∂ Feather</option>
                            <option value="bone">üíÄ Bone/skull</option>
                            <option value="other">üîç Other evidence</option>
                        </select>
                    </div>
                </div>

                <!-- Characteristics -->
                <div class="form-group">
                    <label class="form-label" for="characteristics">
                        <i class="fas fa-clipboard-list" aria-hidden="true"></i> Description / Characteristics
                    </label>
                    <textarea id="characteristics" class="form-textarea" 
                              placeholder="Describe size, color, markings, behavior, age, sex, weather conditions, etc."
                              aria-label="Characteristics description"></textarea>
                </div>

                <!-- Notes -->
                <div class="form-group">
                    <label class="form-label" for="notes">
                        <i class="fas fa-sticky-note" aria-hidden="true"></i> Additional Notes
                    </label>
                    <textarea id="notes" class="form-textarea" 
                              placeholder="Any other relevant observations or comments"
                              aria-label="Additional notes"></textarea>
                </div>

                <!-- Equipment Used -->
                <fieldset class="form-group" aria-labelledby="equipment-legend">
                    <legend id="equipment-legend" class="form-label">
                        <i class="fas fa-tools" aria-hidden="true"></i> Equipment Used
                    </legend>
                    <div class="checkbox-group" role="group" aria-labelledby="equipment-legend">
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="binoculars" aria-label="Binoculars">
                            <i class="fas fa-eye" aria-hidden="true"></i> Binoculars
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="camera" aria-label="Camera">
                            <i class="fas fa-camera" aria-hidden="true"></i> Camera
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="hand-lens" aria-label="Hand lens">
                            <i class="fas fa-search" aria-hidden="true"></i> Hand lens
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="gps" aria-label="GPS">
                            <i class="fas fa-map-pin" aria-hidden="true"></i> GPS
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="microscope" aria-label="Microscope">
                            <i class="fas fa-microscope" aria-hidden="true"></i> Microscope
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" name="equipment" value="other-equipment" aria-label="Other equipment">
                            <i class="fas fa-plus" aria-hidden="true"></i> Other
                        </label>
                    </div>
                    <input type="text" id="other-equipment" class="form-input" 
                           placeholder="Specify other equipment used" style="margin-top: 0.75rem; display: none;"
                           aria-label="Other equipment details">
                </fieldset>

                <!-- Reference Material -->
                <div class="form-group">
                    <label class="form-label" for="references">
                        <i class="fas fa-book-open" aria-hidden="true"></i> Reference Material Used
                    </label>
                    <textarea id="references" class="form-textarea" 
                              placeholder="Field guides, apps, websites, or other references consulted"
                              aria-label="Reference material used"></textarea>
                </div>

                <!-- Photo -->
                <div class="form-group">
                    <label class="form-label">
                        <i class="fas fa-camera" aria-hidden="true"></i> Photo / Evidence
                    </label>
                    <button type="button" id="capture-photo" class="btn btn-outline" aria-label="Take or upload photo">
                        <i class="fas fa-camera-retro" aria-hidden="true"></i> Take photo/Upload
                    </button>
                    <input type="file" id="photo-upload" accept="image/*" capture="environment" 
                           style="display: none;" aria-label="Photo upload">
                    <div class="photo-container">
                        <div class="photo-preview-container">
                            <img id="photo-preview" class="photo-preview" alt="Photo preview" role="presentation">
                            <div id="photo-remove" class="photo-remove" title="Remove photo" aria-label="Remove photo">
                                <i class="fas fa-times" aria-hidden="true"></i>
                            </div>
                        </div>
                        <div id="photo-info" style="margin-top: 0.75rem; font-size: 0.9rem; color: #666; display: none;">
                            <span id="photo-size"><i class="fas fa-weight-hanging" aria-hidden="true"></i> Size: --</span> | 
                            <span id="photo-resolution"><i class="fas fa-expand-alt" aria-hidden="true"></i> Resolution: --</span>
                        </div>
                    </div>
                </div>

                <!-- Submit Button -->
                <button id="record-btn" class="btn btn-primary btn-block" aria-label="Record observation">
                    <i class="fas fa-save" aria-hidden="true"></i> Record Observation
                </button>
            </div>

            <div id="record-status" class="status-message" style="display: none;" role="status" aria-live="polite"></div>
        </div>

        <!-- Logbook Panel -->
        <div id="logbook-panel" class="tab-panel" role="tabpanel" aria-labelledby="tab-logbook" tabindex="0">
            <div class="form-section">
                <h2 class="form-title">
                    <i class="fas fa-book" aria-hidden="true"></i> Observation Logbook
                    <span class="badge" id="observation-count">0 observations</span>
                </h2>
                
                <div class="btn-group">
                    <button id="clear-logbook" class="btn btn-danger" aria-label="Clear all entries">
                        <i class="fas fa-trash-alt" aria-hidden="true"></i> Clear All
                    </button>
                    <button id="import-logbook" class="btn btn-outline" aria-label="Import CSV">
                        <i class="fas fa-file-import" aria-hidden="true"></i> Import CSV
                    </button>
                    <button id="download-template" class="btn btn-outline" aria-label="Download CSV template">
                        <i class="fas fa-download" aria-hidden="true"></i> Download Template
                    </button>
                </div>
                
                <div class="logbook-entries" id="logbook-entries" role="list" aria-label="Observation logbook entries">
                    <!-- Log entries will be inserted here -->
                </div>
                
                <div id="empty-logbook" class="empty-state" aria-live="polite">
                    <i class="fas fa-book-open" aria-hidden="true"></i>
                    <h3>No observations recorded yet</h3>
                    <p>Start by making your first observation in the Record tab!</p>
                </div>
            </div>
        </div>

        <!-- Export Panel -->
        <div id="export-panel" class="tab-panel" role="tabpanel" aria-labelledby="tab-export" tabindex="0">

            <!-- Import Section -->
            <div class="form-section import-section">
                <h2 class="form-title">
                    <i class="fas fa-file-import" aria-hidden="true"></i> Import Observations
                </h2>
                <div class="form-group">
                    <label class="form-label" for="csv-import">
                        <i class="fas fa-file-csv" aria-hidden="true"></i> Import CSV File
                    </label>
                    <input type="file" id="csv-import" accept=".csv" class="form-input" 
                           aria-label="CSV file to import">
                    
                    <label class="form-label" for="json-import" style="margin-top: 1rem;">
                        <i class="fas fa-file-code" aria-hidden="true"></i> Import JSON File
                    </label>
                    <input type="file" id="json-import" accept=".json" class="form-input" 
                           style="margin-top: 0.5rem;" aria-label="JSON file to import">
                    
                    <div class="import-mode">
                        <div class="import-mode-option">
                            <label class="form-label tooltip" for="import-mode">
                                <i class="fas fa-cog" aria-hidden="true"></i> CSV Import Mode
                            </label>
                            <select id="import-mode" class="form-select" aria-label="Import mode">
                                <option value="append">Append to existing data</option>
                                <option value="replace">Replace existing data</option>
                                <option value="merge">Merge and update existing</option>
                            </select>
                        </div>
                        <div class="import-mode-option">
                            <label class="form-label tooltip" for="json-import-mode">
                                <i class="fas fa-cog" aria-hidden="true"></i> JSON Import Mode
                            </label>
                            <select id="json-import-mode" class="form-select" aria-label="JSON import mode">
                                <option value="append">Append to existing data</option>
                                <option value="replace">Replace existing data</option>
                                <option value="merge">Merge and update existing</option>
                            </select>
                        </div>
                    </div>
                                
                    <div class="import-note">
                        <strong><i class="fas fa-info-circle" aria-hidden="true"></i> Required format:</strong> CSV with headers: ID, Timestamp, Observer Name, Scientific Name, Common Name, Location, Latitude, Longitude, Habitat, Observation Type, Characteristics, Equipment, References, Notes, Has Photo.<br>
                        <strong>OR</strong> JSON array of observation objects with proper structure.<br>
                        <strong><i class="fas fa-calendar-alt" aria-hidden="true"></i> Date format:</strong> Use ISO format (YYYY-MM-DDTHH:mm:ss) for best results.<br>
                        <strong><i class="fas fa-shield-alt" aria-hidden="true"></i> Safety note:</strong> Text starting with =, +, -, @ will be prefixed with ' to prevent formula execution.
                    </div>
                    
                    <button id="preview-import" class="btn btn-primary btn-block">
                        <i class="fas fa-eye" aria-hidden="true"></i> Preview CSV Import
                    </button>
                    <button id="preview-json-import" class="btn btn-primary btn-block" style="margin-top: 1rem;">
                        <i class="fas fa-eye" aria-hidden="true"></i> Preview JSON Import
                    </button>
                </div>
                
                <!-- CSV Preview & Validation Section -->
                <div id="csv-preview-section" class="csv-preview-section">
                    <h3><i class="fas fa-search" aria-hidden="true"></i> CSV Preview & Validation</h3>

                    <div id="csv-import-progress" class="pdf-status" style="display: none;">
                        <div id="csv-import-status-text">Importing CSV...</div>
                        <progress id="csv-import-progress-bar" value="0" max="100" aria-label="CSV import progress"></progress>
                        <div id="csv-import-current-action"></div>
                    </div>
                                        
                    <!-- Validation Statistics -->
                    <div id="validation-stats" class="validation-stats" style="display: none;">
                        <div id="stat-valid-rows" class="stat-item stat-valid">
                            <i class="fas fa-check-circle" aria-hidden="true"></i> <span id="valid-count">0</span> valid
                        </div>
                        <div id="stat-invalid-rows" class="stat-item stat-invalid">
                            <i class="fas fa-times-circle" aria-hidden="true"></i> <span id="invalid-count">0</span> invalid
                        </div>
                        <div id="stat-warning-rows" class="stat-item stat-warning">
                            <i class="fas fa-exclamation-triangle" aria-hidden="true"></i> <span id="warning-count">0</span> warnings
                        </div>
                        <div id="stat-skipped-rows" class="stat-item stat-info">
                            <i class="fas fa-forward" aria-hidden="true"></i> <span id="skipped-count">0</span> skipped
                        </div>
                        <div id="stat-metadata-rows" class="stat-item stat-info">
                            <i class="fas fa-info-circle" aria-hidden="true"></i> <span id="metadata-count">0</span> metadata
                        </div>
                    </div>
                    
                    <div id="validation-summary" class="validation-summary"></div>
                    
                    <!-- Mini Map Preview for Coordinates -->
                    <div id="mini-map-container" class="mini-map-preview" style="display: none;" aria-label="Map preview of imported coordinates"></div>
                    
                    <div id="preview-table-container" style="overflow: auto; max-height: 300px; border-radius: var(--border-radius-sm);">
                        <table id="csv-preview-table" class="csv-preview-table" role="grid" aria-label="CSV preview table"></table>
                    </div>
                    <div id="preview-actions" class="btn-group" style="margin-top: 1.5rem;">
                        <button id="confirm-import" class="btn btn-primary">
                            <i class="fas fa-check" aria-hidden="true"></i> Confirm Import
                        </button>
                        <button id="cancel-import" class="btn btn-outline">
                            <i class="fas fa-times" aria-hidden="true"></i> Cancel
                        </button>
                    </div>
                </div>
                
                <!-- JSON Preview Section -->
                <div id="json-preview-section" class="csv-preview-section" style="display: none;">
                    <h3><i class="fas fa-file-code" aria-hidden="true"></i> JSON Preview & Validation</h3>
                    
                    <div id="json-validation-stats" class="validation-stats" style="display: none;">
                        <div id="json-valid-count" class="stat-item stat-valid">
                            <i class="fas fa-check-circle" aria-hidden="true"></i> <span id="json-valid-count-val">0</span> valid
                        </div>
                        <div id="json-invalid-count" class="stat-item stat-invalid">
                            <i class="fas fa-times-circle" aria-hidden="true"></i> <span id="json-invalid-count-val">0</span> invalid
                        </div>
                        <div id="json-photo-count" class="stat-item stat-info">
                            <i class="fas fa-camera" aria-hidden="true"></i> <span id="json-photo-count-val">0</span> with photos
                        </div>
                    </div>
                    
                    <div id="json-validation-summary" class="validation-summary"></div>
                    
                    <div id="json-preview-content" class="json-preview-content" 
                         style="max-height: 200px; overflow: auto; background: #f8f9fa; padding: 1rem; border-radius: var(--border-radius-sm); margin: 1rem 0;"></div>
                    
                    <div id="json-preview-actions" class="btn-group" style="margin-top: 1.5rem;">
                        <button id="confirm-json-import" class="btn btn-primary">
                            <i class="fas fa-check" aria-hidden="true"></i> Confirm Import
                        </button>
                        <button id="cancel-json-import" class="btn btn-outline">
                            <i class="fas fa-times" aria-hidden="true"></i> Cancel
                        </button>
                    </div>
                </div>
                
                <div id="import-status" class="status-message" style="display: none; margin-top: 1.5rem;" role="status" aria-live="polite"></div>
            </div>

            <!-- Export Section -->
            <div class="form-section export-options">
                <h2 class="form-title">
                    <i class="fas fa-file-export" aria-hidden="true"></i> Export Observations
                </h2>
                
                <div class="batch-selection" id="batch-selection" style="display: none;">
                    <h3><i class="fas fa-check-square" aria-hidden="true"></i> Select Observations to Export</h3>
                    <div class="batch-checkboxes" id="batch-checkboxes"></div>
                    <div class="btn-group">
                        <button id="select-all-btn" class="btn btn-outline btn-small">
                            <i class="fas fa-check-double" aria-hidden="true"></i> Select All
                        </button>
                        <button id="deselect-all-btn" class="btn btn-outline btn-small">
                            <i class="fas fa-times" aria-hidden="true"></i> Deselect All
                        </button>
                        <button id="apply-batch-selection" class="btn btn-primary btn-small">
                            <i class="fas fa-check" aria-hidden="true"></i> Apply Selection (<span id="batch-selection-count">0</span>)
                        </button>
                    </div>
                </div>
                
                <div class="export-option-group">
                    <label class="form-label">
                        <i class="fas fa-file" aria-hidden="true"></i> Export Format
                    </label>
                    <div class="export-option">
                        <input type="radio" id="export-pdf" name="export-format" value="pdf" checked aria-label="Export as PDF">
                        <label for="export-pdf">
                            <i class="fas fa-file-pdf" aria-hidden="true"></i> PDF Field Log (with photos)
                        </label>
                    </div>
                    <div class="export-option">
                        <input type="radio" id="export-csv" name="export-format" value="csv" aria-label="Export as CSV">
                        <label for="export-csv">
                            <i class="fas fa-file-csv" aria-hidden="true"></i> CSV Data
                        </label>
                    </div>
                    <div class="export-option">
                        <input type="radio" id="export-json" name="export-format" value="json" aria-label="Export as JSON">
                        <label for="export-json">
                            <i class="fas fa-file-code" aria-hidden="true"></i> JSON (Full data with photos)
                        </label>
                    </div>
                    <div class="export-option">
                        <input type="checkbox" id="enable-batch-selection" aria-label="Enable batch selection">
                        <label for="enable-batch-selection">
                            <i class="fas fa-list-check" aria-hidden="true"></i> Select specific observations
                        </label>
                    </div>
                </div>

                <!-- Export Option Notes -->
                <div id="export-notes" style="margin-top: 1rem;">
                    <div id="csv-export-note" class="import-note" style="display: none;">
                        <strong><i class="fas fa-info-circle" aria-hidden="true"></i> CSV Export:</strong> Exports observation data in CSV format, suitable for spreadsheets and databases.
                    </div>
                    <div id="json-export-note" class="import-note" style="display: none;">
                        <strong><i class="fas fa-info-circle" aria-hidden="true"></i> JSON Export:</strong> Exports complete observation data including photos in JSON format.
                    </div>
                    <div id="pdf-export-note" class="import-note" style="display: block;">
                        <strong><i class="fas fa-info-circle" aria-hidden="true"></i> PDF Export:</strong> Creates a formatted PDF report with photos, suitable for printing and sharing.
                    </div>
                </div>

                <div class="export-option-group">
                    <label class="form-label">
                        <i class="fas fa-calendar-alt" aria-hidden="true"></i> Date Range (Optional)
                    </label>
                    <div class="date-range">
                        <div class="date-input">
                            <label class="form-label" style="font-size: 0.9rem;">From</label>
                            <input type="date" id="date-from" class="form-input" aria-label="Export from date">
                        </div>
                        <div class="date-input">
                            <label class="form-label" style="font-size: 0.9rem;">To</label>
                            <input type="date" id="date-to" class="form-input" aria-label="Export to date">
                        </div>
                    </div>
                </div>

                <button id="generate-export" class="btn btn-secondary btn-block" aria-label="Generate export">
                    <i class="fas fa-file-export" aria-hidden="true"></i> Generate Export
                </button>
            </div>

            <div id="export-status" class="status-message" style="display: none;" role="status" aria-live="polite"></div>
            <div id="pdf-progress" class="pdf-status" style="display: none;">
                <div id="pdf-status-text">Preparing PDF...</div>
                <progress id="pdf-progress-bar" value="0" max="100" aria-label="PDF generation progress"></progress>
                <div id="pdf-current-action"></div>
            </div>
            <div id="export-download" style="display: none; text-align: center; margin-top: 2rem;">
                <a id="download-link" class="btn btn-primary" download aria-label="Download export file">
                    <i class="fas fa-download" aria-hidden="true"></i> Download Export
                </a>
            </div>
        </div>
    </div>

    <!-- Floating Action Button for Mobile -->
    <div class="fab" id="fab-add" title="Add new observation" aria-label="Add new observation">
        <i class="fas fa-plus" aria-hidden="true"></i>
    </div>

<script>
// Main application state
const EcoLens = {
    observations: [],
    currentPhoto: null,
    map: null,
    mapMarker: null,
    mapEnabled: false,
    isLocating: false,
    isGeneratingPDF: false,
    csvPreviewData: null,
    jsonPreviewData: null,
    selectedObservations: new Set(),
    miniMap: null,
    accuracyCircle: null,
    canvasCleanupList: [],
    offlineQueue: [],
    isOnline: navigator.onLine,
    memoryCleanupInterval: null,
    pdfPhotoQueue: [],

    // Initialize the application
    init() {
        console.log('Initializing EcoLens...');
        this.initDarkMode();
        this.loadObservations();
        this.setupEventListeners();
        this.renderLogbook();
        this.updateDateInputs();
        this.setCurrentDateTime();
        
        // Add this line to migrate existing data
        if (this.observations.length > 0) {
            setTimeout(() => this.migrateExistingObservations(), 2000);
        }
        
        // FAB button setup
        const fabBtn = document.getElementById('fab-add');
        if (fabBtn) {
            fabBtn.addEventListener('click', () => {
                this.switchTab('record');
                setTimeout(() => {
                    if (window.innerWidth < 768) {
                        const recordPanel = document.getElementById('record-panel');
                        if (recordPanel) {
                            recordPanel.scrollIntoView({ behavior: 'smooth' });
                        }
                    }
                    const observerNameInput = document.getElementById('observer-name');
                    if (observerNameInput) observerNameInput.focus();
                }, 100);
            });
        }

        // Start memory cleanup interval
        this.memoryCleanupInterval = setInterval(() => {
            this.cleanupMemory();
        }, 30000);

        // Setup offline sync
        this.setupOfflineSync();
    },

    // Initialize dark mode
    initDarkMode() {
        const toggleBtn = document.getElementById('dark-mode-toggle');
        const icon = toggleBtn ? toggleBtn.querySelector('i') : null;
        
        const isDarkMode = localStorage.getItem('ecolens-dark-mode') === 'true';
        
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            if (icon) {
                icon.classList.remove('fa-moon');
                icon.classList.add('fa-sun');
            }
        }
        
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => this.toggleDarkMode());
        }
    },

    // Toggle dark mode - FIXED: Add map refresh
    toggleDarkMode() {
        const toggleBtn = document.getElementById('dark-mode-toggle');
        const icon = toggleBtn ? toggleBtn.querySelector('i') : null;
        
        const isDarkMode = document.body.classList.toggle('dark-mode');
        
        if (icon) {
            if (isDarkMode) {
                icon.classList.remove('fa-moon');
                icon.classList.add('fa-sun');
            } else {
                icon.classList.remove('fa-sun');
                icon.classList.add('fa-moon');
            }
        }
        
        // Save preference
        try {
            localStorage.setItem('ecolens-dark-mode', isDarkMode);
        } catch (e) {
            console.warn('Could not save dark mode preference:', e);
        }
        
        // Refresh map if it exists
        if (this.map) {
            setTimeout(() => {
                try {
                    this.map.invalidateSize();
                    // Force a tile layer refresh
                    this.map.eachLayer((layer) => {
                        if (layer instanceof L.TileLayer) {
                            layer.redraw();
                        }
                    });
                } catch (e) {
                    console.warn('Error refreshing map for dark mode:', e);
                }
            }, 300);
        }
    },

    // Cleanup memory to prevent leaks - ENHANCED
    cleanupMemory() {
        console.log('Running memory cleanup...');
        
        // Clean up canvas elements
        this.cleanupCanvasElements();
        
        // Clean up map layers
        if (this.map && this.map._layers) {
            const layersToRemove = [];
            Object.keys(this.map._layers).forEach(key => {
                const layer = this.map._layers[key];
                // Check for zombie layers
                if (layer && !layer._map && layer.remove) {
                    layersToRemove.push(layer);
                }
            });
            
            layersToRemove.forEach(layer => {
                try {
                    this.map.removeLayer(layer);
                } catch (e) {
                    // Ignore errors
                }
            });
        }
        
        // Clean up blob URLs
        document.querySelectorAll('a[href^="blob:"]').forEach(link => {
            try {
                URL.revokeObjectURL(link.href);
            } catch (e) {
                // Ignore errors
            }
        });
        
        // Force garbage collection if available
        if (window.gc) {
            try {
                window.gc();
            } catch (e) {
                // Ignore errors
            }
        }
    },

    // Setup offline sync
    setupOfflineSync() {
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.showStatus('You are back online', 'success');
            this.processOfflineQueue();
        });

        window.addEventListener('offline', () => {
            this.isOnline = false;
            this.showStatus('You are offline. Observations are saved locally and will sync when online.', 'warning');
        });
    },

    // Process offline queue
    processOfflineQueue() {
        if (this.offlineQueue.length > 0 && this.isOnline) {
            console.log('Processing offline queue:', this.offlineQueue.length, 'items');
            this.offlineQueue = [];
        }
    },

    // Set current date/time in form
    setCurrentDateTime() {
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0];
        const timeStr = now.toTimeString().slice(0, 5);
        
        const dateInput = document.getElementById('observation-date');
        const timeInput = document.getElementById('observation-time');
        
        if (dateInput) dateInput.value = dateStr;
        if (timeInput) timeInput.value = timeStr;
    },

    // Generate a unique observation ID
    generateObservationId() {
        const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        const random = Math.random().toString(36).substring(2, 7);
        return `ECO-${date}-${random}`.toUpperCase();
    },

    // Parse date string
    parseDateString(dateString) {
        if (!dateString || typeof dateString !== 'string') {
            return new Date();
        }
        
        dateString = dateString.trim();
        
        // Try ISO format first
        let date = new Date(dateString);
        if (!isNaN(date.getTime())) {
            return date;
        }
        
        // Try other formats
        const formats = [
            /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/, // ISO with time
            /^(\d{4})-(\d{2})-(\d{2})$/, // ISO date only
            /^(\d{1,2})\/(\d{1,2})\/(\d{4})/, // US format
            /^(\d{1,2})\.(\d{1,2})\.(\d{4})/ // EU format
        ];
        
        for (const pattern of formats) {
            const match = dateString.match(pattern);
            if (match) {
                let year, month, day;
                if (pattern === formats[0] || pattern === formats[1]) {
                    [, year, month, day] = match.map(Number);
                } else if (pattern === formats[2]) {
                    [, month, day, year] = match.map(Number);
                } else if (pattern === formats[3]) {
                    [, day, month, year] = match.map(Number);
                }
                
                if (year && month && day) {
                    const adjustedMonth = month - 1;
                    date = new Date(year, adjustedMonth, day);
                    if (!isNaN(date.getTime())) {
                        return date;
                    }
                }
            }
        }
        
        // Fallback to current date
        console.warn(`Could not parse date: "${dateString}", using current date`);
        return new Date();
    },

    // Sanitize input to prevent XSS
    sanitizeInput(input) {
        if (typeof input !== 'string') return input || '';
        
        const div = document.createElement('div');
        div.textContent = input;
        let sanitized = div.innerHTML;
        
        sanitized = sanitized
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .replace(/\//g, '&#x2F;');
            
        return sanitized.trim();
    },

    // Validate habitat type
    validateHabitat(habitat) {
        const HABITAT_TYPES = [
            'forest', 'wetland', 'grassland', 'coastal', 'urban',
            'agricultural', 'alpine', 'riverine', 'desert', 'other'
        ];
        
        if (HABITAT_TYPES.includes(habitat)) {
            return habitat;
        }
        return 'other';
    },

    // Validate observation type
    validateObservationType(type) {
        const OBSERVATION_TYPES = [
            'direct', 'scat', 'track', 'call', 'nest',
            'roadkill', 'feather', 'bone', 'other'
        ];
        
        if (OBSERVATION_TYPES.includes(type)) {
            return type;
        }
        return 'direct';
    },

    // Create a new observation object with all fields
    createObservation(data) {
        const timestamp = this.parseDateString(data.date + 'T' + data.time);
        
        return {
            id: this.generateObservationId(),
            timestamp: timestamp.toISOString(),
            observerName: this.sanitizeInput(data.observerName || ''),
            scientificName: this.sanitizeInput(data.scientificName || ''),
            commonName: this.sanitizeInput(data.commonName || ''),
            location: {
                text: this.sanitizeInput(data.location || ''),
                coordinates: data.coordinates || null,
                accuracy: data.accuracy || null
            },
            habitat: this.validateHabitat(data.habitat || ''),
            observationType: this.validateObservationType(data.observationType || 'direct'),
            characteristics: this.sanitizeInput(data.characteristics || ''),
            notes: this.sanitizeInput(data.notes || ''),
            equipment: data.equipment || [],
            references: this.sanitizeInput(data.references || ''),
            photo: data.photo || null,
            metadata: {
                deviceInfo: data.metadata?.deviceInfo || navigator.userAgent,
                appVersion: '1.0',
                lastModified: new Date().toISOString(),
                source: data.metadata?.source || 'manual',
                created: timestamp.toISOString()
            }
        };
    },

    // Save observation to localStorage - REPLACE WITH THIS
    async saveObservation(observation) {
        try {
            if (!this.validateObservation(observation)) {
                this.showStatus('Observation validation failed', 'error');
                return false;
            }

            // Process photo data for storage
            let processedObservation = { ...observation };
            
            if (observation.photo) {
                // Create storage-optimized version (store thumbnail only in localStorage)
                processedObservation = {
                    ...observation,
                    photo: {
                        id: observation.photo.id || Date.now(),
                        name: observation.photo.filename || `photo_${Date.now()}.jpg`,
                        thumbnailData: observation.photo.thumbnailData,
                        metadata: observation.photo.metadata
                        // Don't store fullData in localStorage to save space
                    }
                };
                
                // Store full-resolution photo in IndexedDB if available
                if (typeof indexedDB !== 'undefined' && observation.photo.fullData) {
                    await this.storeFullResPhotoInIndexedDB(observation.id, observation.photo);
                }
            }

            this.observations.unshift(processedObservation);
            
            if (!this.isOnline) {
                this.offlineQueue.push({
                    type: 'create',
                    data: processedObservation,
                    timestamp: new Date().toISOString()
                });
            }

            const success = this.saveToLocalStorage();
            
            if (success) {
                console.log('Observation saved with compressed photo');
                return true;
            } else {
                throw new Error('Failed to save to localStorage');
            }
            
        } catch (error) {
            console.error('Error saving observation:', error);
            
            if (error.name === 'QuotaExceededError') {
                this.showStatus('Storage is full. Please export and clear some data.', 'error');
                this.autoClearOldData();
                return false;
            } else {
                this.showStatus('Error saving observation: ' + error.message, 'error');
                return false;
            }
        }
    },

    // Store full-resolution photos separately in IndexedDB - ADD THIS FUNCTION
    async storeFullResPhotoInIndexedDB(observationId, photo) {
        return new Promise((resolve, reject) => {
            if (!photo.fullData) {
                resolve();
                return;
            }
            
            const request = indexedDB.open('EcoLensPhotos', 1);
            
            request.onerror = () => reject(request.error);
            
            request.onsuccess = function() {
                const db = request.result;
                
                // Create transaction
                const transaction = db.transaction(['photos'], 'readwrite');
                const store = transaction.objectStore('photos');
                
                // Store the photo
                const photoRecord = {
                    id: `${observationId}_${photo.id || Date.now()}`,
                    observationId: observationId,
                    photoId: photo.id || Date.now(),
                    fullData: photo.fullData,
                    timestamp: new Date().toISOString()
                };
                store.put(photoRecord);
                
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            };
            
            request.onupgradeneeded = function(event) {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('photos')) {
                    db.createObjectStore('photos', { keyPath: 'id' });
                }
            };
        });
    },

    // Retrieve full-res photos for PDF export - ADD THIS FUNCTION TOO
    async getFullResPhotoForPDF(observationId) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('EcoLensPhotos', 1);
            
            request.onerror = () => reject(request.error);
            
            request.onsuccess = function() {
                const db = request.result;
                const transaction = db.transaction(['photos'], 'readonly');
                const store = transaction.objectStore('photos');
                const getAllRequest = store.getAll();
                
                getAllRequest.onsuccess = function() {
                    const photos = getAllRequest.result.filter(record => 
                        record.observationId === observationId
                    );
                    if (photos.length > 0) {
                        resolve({
                            fullData: photos[0].fullData,
                            id: photos[0].photoId
                        });
                    } else {
                        resolve(null);
                    }
                };
                
                getAllRequest.onerror = () => reject(getAllRequest.error);
            };
        });
    },

    // Validate observation data
    validateObservation(observation) {
        const errors = [];
        
        if (!observation.observerName || observation.observerName.trim() === '') {
            errors.push('Observer name is required');
        }
        
        if (!observation.scientificName || observation.scientificName.trim() === '') {
            errors.push('Scientific name is required');
        }
        
        if (!observation.location || !observation.location.text || observation.location.text.trim() === '') {
            errors.push('Location is required');
        }
        
        if (!observation.habitat || observation.habitat.trim() === '') {
            errors.push('Habitat is required');
        }
        
        if (!observation.observationType || observation.observationType.trim() === '') {
            errors.push('Observation type is required');
        }
        
        if (errors.length > 0) {
            console.error('Observation validation errors:', errors);
            return false;
        }
        
        return true;
    },

    // Save to localStorage with retry logic - FIXED
    saveToLocalStorage(retryCount = 3) {
        for (let i = 0; i < retryCount; i++) {
            try {
                localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
                this.renderLogbook();
                return true;
            } catch (error) {
                console.warn(`Save attempt ${i + 1} failed:`, error);
                
                if (error.name === 'QuotaExceededError') {
                    this.showStatus('Storage is full. Please export and clear some data.', 'error');
                    
                    // Try to auto-clear if we have many observations
                    if (this.observations.length > 20) {
                        if (confirm('Storage is full. Remove oldest 10 observations to free space?')) {
                            this.observations = this.observations.slice(0, this.observations.length - 10);
                            continue; // Retry with fewer observations
                        }
                    }
                    return false;
                }
                
                if (i === retryCount - 1) {
                    throw error;
                }
                
                // Wait before retry
                setTimeout(() => {}, 100);
            }
        }
        return false;
    },

    // Auto-clear old data when storage is full
    autoClearOldData() {
        if (this.observations.length > 30) {
            // Keep only the newest 30 observations
            this.observations = this.observations.slice(0, 30);
            try {
                localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
                this.showStatus('Automatically cleared old data to free space', 'warning');
                return true;
            } catch (e) {
                return false;
            }
        }
        return false;
    },

    // Load observations from localStorage
    loadObservations() {
        let data = null;
        
        try {
            const saved = localStorage.getItem('ecolens_observations');
            data = saved ? JSON.parse(saved) : [];
        } catch (error) {
            console.warn('LocalStorage load failed:', error);
            data = [];
        }
        
        this.observations = Array.isArray(data) ? data : [];
        
        // Clean up any corrupted data
        this.observations = this.observations.filter(obs => this.validateObservation(obs));
        
        return true;
    },

    // Update an existing observation
    updateObservation(id, data) {
        const index = this.observations.findIndex(obs => obs.id === id);
        if (index !== -1) {
            const updatedObservation = {
                ...this.observations[index],
                ...data,
                id: this.observations[index].id,
                metadata: {
                    ...this.observations[index].metadata,
                    lastModified: new Date().toISOString()
                }
            };
            
            if (!this.validateObservation(updatedObservation)) {
                this.showStatus('Update validation failed', 'error');
                return false;
            }
            
            this.observations[index] = updatedObservation;
            
            if (!this.isOnline) {
                this.offlineQueue.push({
                    type: 'update',
                    id: id,
                    data: updatedObservation,
                    timestamp: new Date().toISOString()
                });
            }
            
            return this.saveToLocalStorage();
        }
        return false;
    },

    // Delete an observation
    deleteObservation(id) {
        if (confirm('Are you sure you want to delete this observation?')) {
            const index = this.observations.findIndex(obs => obs.id === id);
            if (index !== -1) {
                const deletedObs = this.observations[index];
                this.observations.splice(index, 1);
                
                if (!this.isOnline) {
                    this.offlineQueue.push({
                        type: 'delete',
                        id: id,
                        data: deletedObs,
                        timestamp: new Date().toISOString()
                    });
                }
                
                return this.saveToLocalStorage();
            }
        }
        return false;
    },

    // Clear all observations
    clearObservations() {
        if (this.observations.length === 0) {
            this.showStatus('Logbook is already empty', 'info', 'logbook');
            return;
        }

        if (confirm('Are you sure you want to clear ALL observations? This cannot be undone.')) {
            const backup = [...this.observations];
            
            this.observations = [];
            try {
                localStorage.removeItem('ecolens_observations');
                this.renderLogbook();
                this.showStatus('All observations cleared successfully', 'success', 'logbook');
                
                sessionStorage.setItem('ecolens_backup', JSON.stringify({
                    data: backup,
                    timestamp: new Date().toISOString()
                }));
                
                setTimeout(() => {
                    sessionStorage.removeItem('ecolens_backup');
                }, 30000);
                
            } catch (error) {
                console.error('Error clearing observations:', error);
                this.observations = backup;
                this.showStatus('Error clearing observations', 'error', 'logbook');
            }
        }
    },

    // Parse CSV line
    parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];
            
            if (char === '"') {
                if (inQuotes && nextChar === '"') {
                    current += '"';
                    i++;
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (char === ',' && !inQuotes) {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        
        result.push(current);
        
        return result.map(field => {
            field = field.trim();
            if (field.startsWith('"') && field.endsWith('"')) {
                field = field.substring(1, field.length - 1);
            }
            field = field.replace(/""/g, '"');
            return this.sanitizeInput(field);
        });
    },

    // Sanitize CSV value
    sanitizeCSVValue(value) {
        if (!value || typeof value !== 'string') return value || '';
        
        value = this.sanitizeInput(value);
        
        const formulaChars = ['=', '+', '-', '@', '\t', '\r'];
        const firstChar = value.charAt(0);
        
        if (formulaChars.includes(firstChar)) {
            return "'" + value;
        }
        
        return value;
    },

    // Validate and parse CSV data - FIXED
    validateAndParseCSV(csvContent) {
        const result = {
            headers: [],
            rows: [],
            errors: [],
            warnings: [],
            metadataRows: 0,
            skippedRows: 0,
            validRows: 0,
            invalidRows: 0,
            warningRows: 0,
            totalRows: 0,
            summary: '',
            hasCoordinates: false,
            coordinates: [],
            headerRowIndex: 0
        };

        try {
            const lines = csvContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            const trimmedLines = lines.map(line => line.trim()).filter(line => line !== '');
            
            if (trimmedLines.length < 2) {
                throw new Error('CSV file is empty or has no data rows');
            }

            // Find header row
            let headerRowIndex = 0;
            for (let i = 0; i < Math.min(10, trimmedLines.length); i++) {
                const potentialHeaders = this.parseCSVLine(trimmedLines[i]);
                if (potentialHeaders.length >= 5) { // Minimum expected headers
                    // Check for common header patterns
                    const lowerHeaders = potentialHeaders.map(h => h.toLowerCase());
                    if (lowerHeaders.some(h => h.includes('name') || h.includes('date') || h.includes('location'))) {
                        headerRowIndex = i;
                        break;
                    }
                }
            }

            result.headers = this.parseCSVLine(trimmedLines[headerRowIndex]).map(h => 
                h.trim().replace(/"/g, '').replace(/^\uFEFF/, '')
            );
            result.headerRowIndex = headerRowIndex;
            
            result.skippedRows = headerRowIndex;

            const normalizedHeaders = result.headers.map(h => h.toLowerCase().replace(/\s+/g, ''));
            
            // Expected headers (case-insensitive)
            const expectedHeaders = [
                'id', 'timestamp', 'observer name', 'scientific name', 'common name', 'location',
                'latitude', 'longitude', 'habitat', 'observation type',
                'characteristics', 'equipment', 'references', 'notes', 'has photo'
            ];
            
            // Check for required headers
            const missingHeaders = expectedHeaders.filter(expected => 
                !normalizedHeaders.includes(expected.toLowerCase().replace(/\s+/g, ''))
            );
            
            if (missingHeaders.length > 0) {
                result.warnings.push(`Missing expected headers: ${missingHeaders.join(', ')}`);
            }

            result.hasCoordinates = normalizedHeaders.includes('latitude') && normalizedHeaders.includes('longitude');

            result.totalRows = trimmedLines.length - headerRowIndex - 1;
            
            for (let i = headerRowIndex + 1; i < trimmedLines.length; i++) {
                const line = trimmedLines[i];
                const rowNumber = i - headerRowIndex;
                
                const rowErrors = [];
                const rowWarnings = [];
                
                try {
                    const rawValues = this.parseCSVLine(line);
                    
                    if (rawValues.every(v => v === '')) {
                        result.skippedRows++;
                        continue;
                    }
                    
                    const rowData = {};
                    
                    result.headers.forEach((header, index) => {
                        rowData[header] = index < rawValues.length ? rawValues[index] : '';
                    });

                    Object.keys(rowData).forEach(key => {
                        if (typeof rowData[key] === 'string') {
                            rowData[key] = this.sanitizeCSVValue(rowData[key]);
                        }
                    });

                    // Check required fields
                    const requiredFields = {
                        'Observer Name': 'observer name',
                        'Scientific Name': 'scientific name',
                        'Location': 'location',
                        'Habitat': 'habitat',
                        'Observation Type': 'observation type'
                    };
                    
                    Object.entries(requiredFields).forEach(([displayName, normalizedName]) => {
                        const headerIndex = normalizedHeaders.indexOf(normalizedName.toLowerCase().replace(/\s+/g, ''));
                        if (headerIndex !== -1) {
                            const header = result.headers[headerIndex];
                            const value = rowData[header];
                            if (!value || value.trim() === '') {
                                rowErrors.push(`Row ${rowNumber}: Missing required field "${displayName}"`);
                            }
                        }
                    });

                    // Parse timestamp
                    const timestampHeaderIndex = normalizedHeaders.indexOf('timestamp');
                    if (timestampHeaderIndex !== -1 && rowData[result.headers[timestampHeaderIndex]]) {
                        const timestampStr = rowData[result.headers[timestampHeaderIndex]];
                        const date = this.parseDateString(timestampStr);
                        if (date) {
                            rowData['_parsedTimestamp'] = date;
                            rowData['_originalTimestamp'] = timestampStr;
                            
                            if (date > new Date()) {
                                rowWarnings.push(`Row ${rowNumber}: Date is in the future`);
                            }
                        } else {
                            rowWarnings.push(`Row ${rowNumber}: Invalid date format. Using current date instead.`);
                            rowData['_parsedTimestamp'] = new Date();
                        }
                    } else if (timestampHeaderIndex !== -1 && !rowData[result.headers[timestampHeaderIndex]]) {
                        rowWarnings.push(`Row ${rowNumber}: Missing timestamp. Using current date.`);
                        rowData['_parsedTimestamp'] = new Date();
                    }

                    // Parse coordinates
                    let hasValidCoords = false;
                    if (result.hasCoordinates) {
                        const latHeaderIndex = normalizedHeaders.indexOf('latitude');
                        const lngHeaderIndex = normalizedHeaders.indexOf('longitude');
                        
                        if (latHeaderIndex !== -1 && lngHeaderIndex !== -1) {
                            const latStr = rowData[result.headers[latHeaderIndex]];
                            const lngStr = rowData[result.headers[lngHeaderIndex]];
                            
                            if (latStr && lngStr) {
                                const lat = parseFloat(latStr);
                                const lng = parseFloat(lngStr);
                                
                                if (isNaN(lat) || lat < -90 || lat > 90) {
                                    rowWarnings.push(`Row ${rowNumber}: Invalid Latitude value "${latStr}". Must be between -90 and 90.`);
                                } else if (isNaN(lng) || lng < -180 || lng > 180) {
                                    rowWarnings.push(`Row ${rowNumber}: Invalid Longitude value "${lngStr}". Must be between -180 and 180.`);
                                } else {
                                    hasValidCoords = true;
                                    result.coordinates.push({ lat, lng });
                                    rowData['_coordinateStatus'] = '‚úÖ Valid coordinates';
                                }
                            } else if (latStr || lngStr) {
                                rowWarnings.push(`Row ${rowNumber}: Incomplete coordinates. Provide both Latitude and Longitude or leave both empty.`);
                            }
                        }
                    }

                    // Parse equipment
                    const equipmentHeaderIndex = normalizedHeaders.indexOf('equipment');
                    if (equipmentHeaderIndex !== -1 && rowData[result.headers[equipmentHeaderIndex]]) {
                        const equipmentStr = rowData[result.headers[equipmentHeaderIndex]];
                        const equipmentArray = equipmentStr.split(';')
                            .map(item => this.sanitizeInput(item.trim()))
                            .filter(item => item !== '');
                        
                        rowData['_parsedEquipment'] = equipmentArray;
                    }

                    result.rows.push({
                        data: rowData,
                        errors: rowErrors,
                        warnings: rowWarnings,
                        isValid: rowErrors.length === 0,
                        hasValidCoords: hasValidCoords,
                        rowNumber: rowNumber,
                        originalLineNumber: i + 1
                    });

                    if (rowErrors.length === 0) {
                        result.validRows++;
                        if (rowWarnings.length > 0) {
                            result.warningRows++;
                        }
                    } else {
                        result.invalidRows++;
                    }

                    result.errors.push(...rowErrors);
                    result.warnings.push(...rowWarnings);

                } catch (error) {
                    console.error(`Error parsing row ${rowNumber}:`, error);
                    const errorMsg = `Row ${rowNumber}: ${error.message}`;
                    result.errors.push(errorMsg);
                    result.rows.push({
                        data: null,
                        errors: [errorMsg],
                        warnings: [],
                        isValid: false,
                        hasValidCoords: false,
                        rowNumber: rowNumber,
                        originalLineNumber: i + 1
                    });
                    result.invalidRows++;
                }
            }

            result.summary = `Found ${result.totalRows} data rows (${result.skippedRows} metadata rows skipped): ${result.validRows} valid, ${result.invalidRows} invalid, ${result.warningRows} with warnings`;
            
            return result;

        } catch (error) {
            console.error('CSV parsing error:', error);
            result.errors.push(`CSV parsing error: ${error.message}`);
            return result;
        }
    },

    // Import observations from CSV - FIXED
    importObservationsFromCSV(validationResult, mode = 'append') {
        return new Promise((resolve, reject) => {
            try {
                const importedObservations = [];
                let successCount = 0;
                let errorCount = 0;
                let updateCount = 0;
                let duplicateCount = 0;
                let skippedCount = 0;

                const progressUI = document.getElementById('csv-import-progress');
                const progressBar = document.getElementById('csv-import-progress-bar');
                const statusText = document.getElementById('csv-import-status-text');
                
                if (progressUI && progressBar && statusText) {
                    progressUI.style.display = 'block';
                    progressBar.value = 0;
                    statusText.textContent = 'Starting import...';
                }

                const processRow = (row, index, total) => {
                    try {
                        if (!row.isValid || !row.data) {
                            errorCount++;
                            skippedCount++;
                            return null;
                        }

                        let equipmentArray = [];
                        if (row.data['_parsedEquipment']) {
                            equipmentArray = row.data['_parsedEquipment'];
                        } else if (row.data['Equipment']) {
                            equipmentArray = row.data['Equipment'].split(';')
                                .map(item => this.sanitizeInput(item.trim()))
                                .filter(item => item !== '');
                        }
                        
                        // Get coordinates
                        let coordinates = null;
                        if (validationResult.hasCoordinates && row.data['Latitude'] && row.data['Longitude']) {
                            const lat = parseFloat(row.data['Latitude']);
                            const lng = parseFloat(row.data['Longitude']);
                            if (!isNaN(lat) && !isNaN(lng)) {
                                coordinates = { lat, lng };
                            }
                        }
                        
                        const observation = {
                            id: row.data['ID'] || this.generateObservationId(),
                            timestamp: (row.data['_parsedTimestamp'] || new Date()).toISOString(),
                            observerName: row.data['Observer Name'] || '',
                            scientificName: row.data['Scientific Name'] || '',
                            commonName: row.data['Common Name'] || '',
                            location: {
                                text: row.data['Location'] || '',
                                coordinates: coordinates,
                                accuracy: null
                            },
                            habitat: row.data['Habitat'] || '',
                            observationType: row.data['Observation Type'] || 'direct',
                            characteristics: row.data['Characteristics'] || '',
                            equipment: equipmentArray,
                            references: row.data['References'] || '',
                            notes: row.data['Notes'] || '',
                            photo: null,
                            source: 'csv_import'
                        };

                        if (this.validateObservation(observation)) {
                            importedObservations.push(observation);
                            successCount++;
                            return observation;
                        } else {
                            errorCount++;
                            return null;
                        }
                        
                    } catch (error) {
                        console.warn(`Error creating observation from row ${row.rowNumber}:`, error);
                        errorCount++;
                        return null;
                    }
                };

                // Process all rows
                validationResult.rows.forEach((row, index) => {
                    const progress = Math.round((index / validationResult.rows.length) * 100);
                    this.updateCSVImportProgress(progress, index + 1, validationResult.rows.length);
                    processRow(row, index, validationResult.rows.length);
                });

                // Finalize import
                this.updateCSVImportProgress(100, validationResult.rows.length, validationResult.rows.length);

                if (importedObservations.length === 0) {
                    throw new Error('No valid observations found in CSV file');
                }

                const existingIds = new Set(this.observations.map(obs => obs.id));
                let finalObservations = [];
                
                switch (mode) {
                    case 'replace':
                        finalObservations = importedObservations;
                        break;
                        
                    case 'merge':
                        finalObservations = [...this.observations];
                        
                        importedObservations.forEach(importedObs => {
                            const existingIndex = finalObservations.findIndex(obs => obs.id === importedObs.id);
                            
                            if (existingIndex !== -1) {
                                const existingObs = finalObservations[existingIndex];
                                finalObservations[existingIndex] = {
                                    ...existingObs,
                                    ...importedObs,
                                    metadata: {
                                        ...existingObs.metadata,
                                        source: 'merged',
                                        lastModified: new Date().toISOString(),
                                        originalSource: existingObs.metadata.source
                                    }
                                };
                                updateCount++;
                            } else {
                                finalObservations.push(importedObs);
                            }
                        });
                        break;
                        
                    case 'append':
                    default:
                        const uniqueImports = importedObservations.filter(obs => {
                            if (existingIds.has(obs.id)) {
                                duplicateCount++;
                                return false;
                            }
                            return true;
                        });
                        
                        finalObservations = [...this.observations, ...uniqueImports];
                        break;
                }

                finalObservations.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                this.observations = finalObservations;
                try {
                    localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
                } catch (error) {
                    console.error('Error saving imported data:', error);
                    if (error.name === 'QuotaExceededError') {
                        if (this.autoClearOldData()) {
                            localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
                        } else {
                            throw new Error('Storage is full. Please export and clear some data before importing.');
                        }
                    } else {
                        throw error;
                    }
                }
                
                if (progressUI) {
                    setTimeout(() => {
                        progressUI.style.display = 'none';
                    }, 1000);
                }

                this.renderLogbook();

                const result = {
                    success: true,
                    imported: successCount,
                    updated: updateCount,
                    duplicates: duplicateCount,
                    errors: errorCount,
                    skipped: skippedCount,
                    total: this.observations.length,
                    mode: mode,
                    summary: `Imported ${successCount} observations, updated ${updateCount}, ${duplicateCount} duplicates skipped, ${errorCount} errors. Total observations: ${this.observations.length}`
                };

                resolve(result);

            } catch (error) {
                console.error('Import error:', error);
                
                if (progressUI) progressUI.style.display = 'none';
                
                reject(error);
            }
        });
    },

    // Validate JSON data
    validateJSONData(jsonData) {
        const result = {
            observations: [],
            errors: [],
            warnings: [],
            validCount: 0,
            invalidCount: 0,
            summary: ''
        };

        try {
            if (!Array.isArray(jsonData)) {
                if (jsonData.observations && Array.isArray(jsonData.observations)) {
                    jsonData = jsonData.observations;
                } else {
                    throw new Error('JSON data must be an array of observations or contain an "observations" array');
                }
            }

            if (jsonData.length > 10000) {
                throw new Error('JSON file contains too many observations (maximum 10,000)');
            }

            jsonData.forEach((obs, index) => {
                const obsErrors = [];
                const obsWarnings = [];

                if (!obs.observerName || obs.observerName.trim() === '') {
                    obsErrors.push(`Observation ${index + 1}: Missing observerName`);
                }
                if (!obs.scientificName || obs.scientificName.trim() === '') {
                    obsErrors.push(`Observation ${index + 1}: Missing scientificName`);
                }
                if (!obs.location || !obs.location.text || obs.location.text.trim() === '') {
                    obsErrors.push(`Observation ${index + 1}: Missing location`);
                }
                if (!obs.habitat || obs.habitat.trim() === '') {
                    obsErrors.push(`Observation ${index + 1}: Missing habitat`);
                }
                if (!obs.observationType || obs.observationType.trim() === '') {
                    obsErrors.push(`Observation ${index + 1}: Missing observationType`);
                }

                if (obs.photo && obs.photo.data) {
                    if (obs.photo.data.length > 5000000) {
                        obsWarnings.push(`Observation ${index + 1}: Photo is very large (${Math.round(obs.photo.data.length / 1024)}KB)`);
                    }
                    
                    if (!obs.photo.data.startsWith('data:image/')) {
                        obsWarnings.push(`Observation ${index + 1}: Photo data doesn't appear to be in correct format`);
                    }
                }

                if (obs.location && obs.location.coordinates) {
                    const { lat, lng } = obs.location.coordinates;
                    if (lat < -90 || lat > 90 || isNaN(lat)) {
                        obsErrors.push(`Observation ${index + 1}: Invalid latitude ${lat}`);
                    }
                    if (lng < -180 || lng > 180 || isNaN(lng)) {
                        obsErrors.push(`Observation ${index + 1}: Invalid longitude ${lng}`);
                    }
                }

                const normalizedObs = {
                    ...obs,
                    source: 'json_import'
                };

                result.observations.push({
                    data: normalizedObs,
                    errors: obsErrors,
                    warnings: obsWarnings,
                    isValid: obsErrors.length === 0,
                    index: index + 1
                });

                if (obsErrors.length === 0) {
                    result.validCount++;
                } else {
                    result.invalidCount++;
                }

                result.errors.push(...obsErrors);
                result.warnings.push(...obsWarnings);
            });

            result.summary = `Found ${jsonData.length} observations: ${result.validCount} valid, ${result.invalidCount} invalid`;
            return result;

        } catch (error) {
            result.errors.push(`JSON validation error: ${error.message}`);
            return result;
        }
    },

    // Import observations from JSON
    importObservationsFromJSON(validationResult, mode = 'append') {
        try {
            const importedObservations = validationResult.observations
                .filter(obs => obs.isValid)
                .map(obs => obs.data);
            
            if (importedObservations.length === 0) {
                throw new Error('No valid observations found in JSON file');
            }

            const errorCount = validationResult.invalidCount;
            const existingIds = new Set(this.observations.map(obs => obs.id));
            let updateCount = 0;
            let duplicateCount = 0;

            switch (mode) {
                case 'replace':
                    this.observations = importedObservations;
                    break;
                    
                case 'merge':
                    const observationMap = new Map();
                    this.observations.forEach(obs => {
                        observationMap.set(obs.id, obs);
                    });
                    
                    importedObservations.forEach(importedObs => {
                        if (observationMap.has(importedObs.id)) {
                            const existing = observationMap.get(importedObs.id);
                            observationMap.set(importedObs.id, {
                                ...existing,
                                ...importedObs,
                                metadata: {
                                    ...existing.metadata,
                                    source: 'merged_import',
                                    lastModified: new Date().toISOString()
                                }
                            });
                            updateCount++;
                        } else {
                            observationMap.set(importedObs.id, importedObs);
                        }
                    });
                    
                    this.observations = Array.from(observationMap.values());
                    break;
                    
                case 'append':
                default:
                    const uniqueImports = importedObservations.filter(obs => {
                        if (existingIds.has(obs.id)) {
                            duplicateCount++;
                            return false;
                        }
                        return true;
                    });
                    this.observations = [...this.observations, ...uniqueImports];
                    break;
            }

            this.observations.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            try {
                localStorage.setItem('ecolens_observations', JSON.stringify(this.observations));
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    if (!this.autoClearOldData()) {
                        throw new Error('Storage is full. Please export and clear some data before importing.');
                    }
                } else {
                    throw error;
                }
            }
            
            this.renderLogbook();

            return {
                success: true,
                imported: importedObservations.length,
                updated: updateCount,
                duplicates: duplicateCount,
                errors: errorCount,
                total: this.observations.length,
                mode: mode,
                hasPhotos: importedObservations.some(obs => obs.photo)
            };

        } catch (error) {
            console.error('JSON import error:', error);
            throw error;
        }
    },

    // Export to CSV
    exportToCSV(observations, dateFrom, dateTo, selectedIds) {
        const headers = [
            'ID', 'Timestamp', 'Observer Name', 'Scientific Name', 'Common Name', 'Location',
            'Latitude', 'Longitude', 'Habitat', 'Observation Type',
            'Characteristics', 'Equipment', 'References', 'Notes', 'Has Photo'
        ];
        
        const rows = observations.map(obs => {
            const equipmentStr = Array.isArray(obs.equipment) 
                ? obs.equipment.map(eq => {
                    if (eq.startsWith('other: ')) {
                        return eq.substring(7);
                    }
                    return eq;
                }).join('; ') 
                : (obs.equipment || '');
            
            return [
                obs.id,
                obs.timestamp,
                this.escapeCSV(obs.observerName),
                this.escapeCSV(obs.scientificName),
                this.escapeCSV(obs.commonName || ''),
                this.escapeCSV(obs.location.text),
                obs.location.coordinates?.lat || '',
                obs.location.coordinates?.lng || '',
                this.escapeCSV(obs.habitat),
                this.escapeCSV(obs.observationType),
                this.escapeCSV(obs.characteristics || ''),
                this.escapeCSV(equipmentStr),
                this.escapeCSV(obs.references || ''),
                this.escapeCSV(obs.notes || ''),
                obs.photo ? 'Yes' : 'No'
            ];
        });
        
        let csvContent = '';
        
        csvContent += '# EcoLens Export\n';
        csvContent += `# Exported: ${new Date().toISOString()}\n`;
        csvContent += `# Total Observations: ${observations.length}\n`;
        if (dateFrom || dateTo) {
            csvContent += `# Date Range: ${dateFrom || 'Start'} to ${dateTo || 'End'}\n`;
        }
        if (selectedIds) {
            csvContent += `# Selection: Custom (${selectedIds.size} observations)\n`;
        } else {
            csvContent += '# Selection: All observations\n';
        }
        csvContent += '#\n';
        csvContent += '# IMPORTANT: Keep this header row intact for re-import\n';
        csvContent += '#\n';
        
        csvContent += headers.join(',') + '\n';
        
        rows.forEach(row => {
            csvContent += row.join(',') + '\n';
        });
        
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const filename = selectedIds ? 
            `EcoLens_Selected_Export_${new Date().toISOString().slice(0,10)}.csv` :
            `EcoLens_Export_${new Date().toISOString().slice(0,10)}.csv`;
        
        this.downloadFile(url, filename);
        this.showStatus(`Exported ${observations.length} observations to CSV`, 'success', 'export');
    },

    // Escape CSV values properly
    escapeCSV(value) {
        if (value === null || value === undefined) return '';
        
        const str = String(value);
        if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
            return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
    },

    // Export to JSON
    exportToJSON(observations, dateFrom, dateTo, selectedIds) {
        const cleanObservations = observations.map(obs => {
            const cleanObs = { ...obs };
            delete cleanObs._map;
            delete cleanObs._marker;
            return cleanObs;
        });
        
        const exportData = {
            metadata: {
                exported: new Date().toISOString(),
                app: 'EcoLens',
                version: '1.0',
                count: cleanObservations.length,
                dateRange: dateFrom || dateTo ? `${dateFrom || 'Start'} to ${dateTo || 'End'}` : 'All observations',
                selection: selectedIds ? 'Custom selection' : 'All observations',
                warning: 'Contains potentially sensitive location data'
            },
            observations: cleanObservations
        };
        
        const jsonContent = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const filename = `EcoLens_Full_Export_${new Date().toISOString().slice(0,10)}.json`;
        this.downloadFile(url, filename);
        
        const photoCount = observations.filter(obs => obs.photo).length;
        this.showStatus(`Exported ${observations.length} observations (${photoCount} with photos) to JSON`, 'success', 'export');
    },

    // Export to PDF - ENHANCED to include photos
    exportToPDF(observations, dateFrom, dateTo, selectedIds) {
        if (this.isGeneratingPDF) {
            this.showStatus('PDF generation already in progress', 'warning', 'export');
            return;
        }

        if (typeof window.jspdf === 'undefined') {
            this.showStatus('PDF export requires jsPDF library. Please include it in your HTML.', 'error', 'export');
            return;
        }

        this.isGeneratingPDF = true;
        const exportBtn = document.getElementById('generate-export');
        const originalText = exportBtn ? exportBtn.innerHTML : 'Generate Export';
        
        if (exportBtn) {
            exportBtn.innerHTML = '<span class="loading"></span> Generating PDF...';
            exportBtn.disabled = true;
        }

        const progressUI = document.getElementById('pdf-progress');
        const progressBar = document.getElementById('pdf-progress-bar');
        const statusText = document.getElementById('pdf-status-text');
        
        if (progressUI) progressUI.style.display = 'block';
        if (progressBar) progressBar.value = 0;
        if (statusText) statusText.textContent = 'Preparing PDF document...';

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4',
            compress: true
        });

        const margin = 15;
        const pageWidth = doc.internal.pageSize.width;
        const pageHeight = doc.internal.pageSize.height;
        const contentWidth = pageWidth - (margin * 2);
        let y = margin;
        let currentPage = 1;
        const totalObservations = observations.length;
        let processedObservations = 0;

        const addWrappedText = (text, x, startY, maxWidth, lineHeight = 5, maxLines = null) => {
            if (!text || text.trim() === '') return startY;
            
            const lines = doc.splitTextToSize(text, maxWidth);
            const linesToShow = maxLines ? lines.slice(0, maxLines) : lines;
            
            const requiredSpace = linesToShow.length * lineHeight;
            if (y + requiredSpace > pageHeight - margin) {
                doc.addPage();
                currentPage++;
                y = margin;
                
                doc.setFontSize(10);
                doc.setTextColor(100);
                doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
                y += 5;
                
                doc.setDrawColor(200);
                doc.line(margin, y, pageWidth - margin, y);
                y += 10;
                startY = y;
            }
            
            linesToShow.forEach((line, index) => {
                doc.text(line, x, startY + (index * lineHeight));
            });
            
            const finalY = startY + (linesToShow.length * lineHeight);
            
            if (maxLines && lines.length > maxLines) {
                doc.setFontSize(8);
                doc.setTextColor(120);
                doc.text('... (continued)', x, finalY);
                return finalY + 4;
            }
            
            return finalY;
        };

                const addPhotoToPDF = async (observationId, doc, x, y, width = 60, height = 40) => {
            return new Promise((resolve) => {
                // Try to get full-resolution photo from IndexedDB
                this.getFullResPhotoForPDF(observationId).then(fullResPhoto => {
                    const photoData = fullResPhoto ? fullResPhoto.fullData : null;
                    
                    if (!photoData) {
                        // Try to get from observation data
                        const obs = observations.find(o => o.id === observationId);
                        if (obs && obs.photo && obs.photo.thumbnailData) {
                            photoData = obs.photo.thumbnailData;
                        } else {
                            resolve(y);
                            return;
                        }
                    }

                    try {
                        // Check if we need to add a new page for the photo
                        if (y + height > pageHeight - margin) {
                            doc.addPage();
                            currentPage++;
                            y = margin;
                            
                            doc.setFontSize(10);
                            doc.setTextColor(100);
                            doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
                            y += 15;
                        }

                        // Add photo with caption
                        doc.setFontSize(9);
                        doc.setTextColor(100);
                        doc.text('Photo:', x, y);
                        y += 4;

                        // Add the image
                        const img = new Image();
                        img.onload = () => {
                            try {
                                doc.addImage(img, 'JPEG', x, y, width, height);
                                y += height + 5;
                                resolve(y);
                            } catch (error) {
                                console.error('Error adding image to PDF:', error);
                                doc.text('[Photo could not be embedded]', x, y);
                                y += 10;
                                resolve(y);
                            }
                        };
                        img.onerror = () => {
                            doc.text('[Photo could not be loaded]', x, y);
                            y += 10;
                            resolve(y);
                        };
                        img.src = photoData;
                    } catch (error) {
                        console.error('Error in addPhotoToPDF:', error);
                        doc.text('[Photo error]', x, y);
                        y += 10;
                        resolve(y);
                    }
                }).catch(error => {
                    console.error('Error getting full-res photo:', error);
                    resolve(y);
                });
            });
        };

        const updateProgress = (step, action) => {
            const progress = Math.round((processedObservations / totalObservations) * 100);
            if (progressBar) {
                progressBar.value = progress;
            }
            
            if (step === 'observation') {
                processedObservations++;
                if (statusText) statusText.textContent = `Processing observation ${processedObservations} of ${totalObservations}`;
            }
        };

        // Start PDF generation with cover page
        setTimeout(async () => {
            try {
                updateProgress('cover', 'Creating cover page...');
                
                doc.setFontSize(24);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(40, 100, 60);
                doc.text('ECOLENS FIELD LOG', pageWidth / 2, 60, { align: 'center' });
                
                doc.setFontSize(16);
                doc.setTextColor(80);
                doc.text('Field Observation Report', pageWidth / 2, 75, { align: 'center' });
                
                doc.setFontSize(12);
                doc.setFont('helvetica', 'normal');
                y = 100;
                
                let dateRangeText = 'All observations';
                if (dateFrom || dateTo) {
                    dateRangeText = `From: ${dateFrom || 'Start'} to ${dateTo || 'End'}`;
                }
                
                doc.text(`Report Period: ${dateRangeText}`, pageWidth / 2, y, { align: 'center' });
                y += 10;
                doc.text(`Total Observations: ${totalObservations}`, pageWidth / 2, y, { align: 'center' });
                y += 10;
                doc.text(`Exported: ${new Date().toLocaleString()}`, pageWidth / 2, y, { align: 'center' });
                y += 10;
                doc.text(`Selection: ${selectedIds ? 'Custom selection' : 'All observations'}`, pageWidth / 2, y, { align: 'center' });
                y += 10;
                doc.text(`Exported by: ${observations[0]?.observerName || 'EcoLens User'}`, pageWidth / 2, y, { align: 'center' });
                y += 20;
                
                doc.setFontSize(10);
                doc.setTextColor(100);
                doc.text('This report contains detailed field observations including photos,', pageWidth / 2, y, { align: 'center' });
                y += 5;
                doc.text('location data, and comprehensive metadata for each record.', pageWidth / 2, y, { align: 'center' });
                
                // Add pages for each observation
                for (let i = 0; i < observations.length; i++) {
                    const obs = observations[i];
                    
                    doc.addPage();
                    currentPage++;
                    y = margin;
                    
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text(`EcoLens Field Log - Page ${currentPage}`, margin, y);
                    y += 5;
                    
                    doc.setDrawColor(200);
                    doc.line(margin, y, pageWidth - margin, y);
                    y += 10;
                    
                    updateProgress('observation', `Adding observation: ${obs.scientificName}`);
                    
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor(40, 40, 40);
                    doc.text(`Observation ${i + 1}: ${obs.id}`, margin, y);
                    y += 10;
                    
                    const col1X = margin;
                    const col2X = margin + (contentWidth / 2) + 5;
                    const columnWidth = (contentWidth / 2) - 5;
                    
                    let col1Y = y;
                    let col2Y = y;
                    
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'bold');
                    doc.text('BASIC INFORMATION', col1X, col1Y);
                    col1Y += 7;
                    doc.setFont('helvetica', 'normal');
                    
                    const col1Items = [
                        { key: 'Date/Time', value: new Date(obs.timestamp).toLocaleString() },
                        { key: 'Observer', value: obs.observerName },
                        { key: 'Scientific Name', value: obs.scientificName },
                        { key: 'Common Name', value: obs.commonName || 'Not specified' },
                        { key: 'Habitat', value: this.capitalizeFirst(obs.habitat) },
                        { key: 'Observation Type', value: this.formatObservationType(obs.observationType) }
                    ];
                    
                    col1Items.forEach(item => {
                        doc.setFont('helvetica', 'bold');
                        const keyText = `${item.key}: `;
                        const keyWidth = doc.getTextWidth(keyText);
                        doc.text(keyText, col1X, col1Y);
                        
                        doc.setFont('helvetica', 'normal');
                        col1Y = addWrappedText(item.value, col1X + keyWidth, col1Y, columnWidth - keyWidth, 5, 8);
                        col1Y += 2;
                    });
                    
                    doc.setFont('helvetica', 'bold');
                    doc.text('LOCATION & EQUIPMENT', col2X, col2Y);
                    col2Y += 7;
                    doc.setFont('helvetica', 'normal');
                    
                    const col2Items = [];
                    
                    col2Items.push({ key: 'Location', value: obs.location.text });
                    
                    if (obs.location.coordinates) {
                        const coords = `Lat: ${obs.location.coordinates.lat.toFixed(5)}, Lng: ${obs.location.coordinates.lng.toFixed(5)}`;
                        col2Items.push({ key: 'Coordinates', value: coords });
                    }
                    
                    if (obs.equipment && obs.equipment.length > 0) {
                        const equipmentText = obs.equipment.map(eq => this.formatEquipment(eq)).join(', ');
                        col2Items.push({ key: 'Equipment Used', value: equipmentText });
                    }
                    
                    if (obs.references) {
                        col2Items.push({ key: 'References', value: obs.references });
                    }
                    
                    col2Items.forEach(item => {
                        doc.setFont('helvetica', 'bold');
                        const keyText = `${item.key}: `;
                        const keyWidth = doc.getTextWidth(keyText);
                        doc.text(keyText, col2X, col2Y);
                        
                        doc.setFont('helvetica', 'normal');
                        col2Y = addWrappedText(item.value, col2X + keyWidth, col2Y, columnWidth - keyWidth, 5, 8);
                        col2Y += 2;
                    });
                    
                    y = Math.max(col1Y, col2Y) + 15;
                    
                    // Add photo if available
                    if (obs.photo) {
                        y = await addPhotoToPDF(obs.id, doc, margin, y);
                    }
                    
                    if (obs.characteristics) {
                        y += 5;
                        
                        doc.setFontSize(12);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(40, 40, 40);
                        doc.text('DESCRIPTION / CHARACTERISTICS', margin, y);
                        y += 8;
                        
                        doc.setDrawColor(100, 150, 100);
                        doc.line(margin, y, margin + 50, y);
                        y += 10;
                        
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(60);
                        
                        y = addWrappedText(obs.characteristics, margin, y, contentWidth, 5);
                        y += 10;
                    }
                    
                    if (obs.notes) {
                        y += 5;
                        
                        doc.setFontSize(12);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(40, 40, 40);
                        doc.text('ADDITIONAL NOTES', margin, y);
                        y += 8;
                        
                        doc.setDrawColor(100, 150, 100);
                        doc.line(margin, y, margin + 50, y);
                        y += 10;
                        
                        doc.setFontSize(10);
                        doc.setFont('helvetica', 'normal');
                        doc.setTextColor(60);
                        
                        y = addWrappedText(obs.notes, margin, y, contentWidth, 5);
                        y += 10;
                    }
                    
                    doc.setFontSize(8);
                    doc.setTextColor(120);
                    doc.setFont('helvetica', 'italic');
                    
                    const metadataLines = [
                        `Record ID: ${obs.id}`,
                        `Created: ${new Date(obs.timestamp).toLocaleString()}`,
                        `Last Modified: ${new Date(obs.metadata.lastModified).toLocaleString()}`
                    ];
                    
                    metadataLines.forEach(line => {
                        doc.text(line, margin, y);
                        y += 4;
                    });
                    
                    y += 10;
                    
                    // Yield to browser every few observations
                    if (i % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
                
                updateProgress('save', 'Finalizing PDF...');
                
                const filename = selectedIds ?
                    `EcoLens_Selected_Report_${new Date().toISOString().slice(0,10)}.pdf` :
                    `EcoLens_Field_Log_${new Date().toISOString().slice(0,10)}.pdf`;
                
                const pdfBlob = doc.output('blob');
                const pdfUrl = URL.createObjectURL(pdfBlob);
                
                if (progressBar) progressBar.value = 100;
                if (statusText) statusText.textContent = 'PDF generation complete!';
                
                setTimeout(() => {
                    this.downloadFile(pdfUrl, filename);
                    this.showStatus(`Successfully exported ${observations.length} observations to PDF`, 'success', 'export');
                    
                    if (exportBtn) {
                        exportBtn.innerHTML = originalText;
                        exportBtn.disabled = false;
                    }
                    this.isGeneratingPDF = false;
                    
                    if (progressUI) {
                        setTimeout(() => {
                            progressUI.style.display = 'none';
                        }, 3000);
                    }
                    
                }, 500);

            } catch (error) {
                console.error('Error generating PDF:', error);
                this.showStatus(`Error generating PDF: ${error.message}`, 'error', 'export');
                
                if (exportBtn) {
                    exportBtn.innerHTML = originalText;
                    exportBtn.disabled = false;
                }
                this.isGeneratingPDF = false;
                if (progressUI) progressUI.style.display = 'none';
            }
        }, 100);
    },

    // Download file helper
    downloadFile(url, filename) {
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        
        setTimeout(() => {
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }, 100);
    },

    // Get filtered observations for export
    getFilteredObservations(startDate = null, endDate = null, selectedIds = null) {
        let filtered = this.observations;
        
        if (startDate || endDate) {
            filtered = filtered.filter(obs => {
                const obsDate = new Date(obs.timestamp);
                if (startDate && obsDate < new Date(startDate)) return false;
                if (endDate && obsDate > new Date(endDate + 'T23:59:59')) return false;
                return true;
            });
        }
        
        if (selectedIds && selectedIds.size > 0) {
            filtered = filtered.filter(obs => selectedIds.has(obs.id));
        }
        
        return filtered;
    },

    // Setup all event listeners - FIXED: Photo removal
    setupEventListeners() {
        // Tab navigation
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const tab = btn.dataset.tab;
                this.switchTab(tab);
            });
        });

        // Set current date/time
        const setNowBtn = document.getElementById('set-now');
        if (setNowBtn) {
            setNowBtn.addEventListener('click', () => {
                this.setCurrentDateTime();
            });
        }

        // Record observation
        const recordBtn = document.getElementById('record-btn');
        if (recordBtn) {
            recordBtn.addEventListener('click', () => {
                this.handleRecordObservation();
            });
        }

        // Map controls
        const toggleMapBtn = document.getElementById('toggle-map');
        if (toggleMapBtn) {
            toggleMapBtn.addEventListener('click', () => {
                this.toggleMap();
            });
        }

        const useMyLocationBtn = document.getElementById('use-my-location');
        if (useMyLocationBtn) {
            useMyLocationBtn.addEventListener('click', () => {
                this.getUserLocation();
            });
        }

        // Photo handling - SIMPLIFIED FIX
        const photoRemoveBtn = document.getElementById('photo-remove');
        if (photoRemoveBtn) {
            // Add click event to the remove button
            photoRemoveBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.removePhoto();
            });
        }

        // Capture button handler
        const capturePhotoBtn = document.getElementById('capture-photo');
        if (capturePhotoBtn) {
            capturePhotoBtn.addEventListener('click', () => {
                document.getElementById('photo-upload').click();
            });
        }

        // File upload handler
        const photoUpload = document.getElementById('photo-upload');
        if (photoUpload) {
            photoUpload.addEventListener('change', (e) => {
                this.handlePhotoUpload(e);
            });
        }

        // Equipment checkboxes
        document.querySelectorAll('input[name="equipment"]').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                if (e.target.value === 'other-equipment') {
                    const otherEquipment = document.getElementById('other-equipment');
                    if (otherEquipment) {
                        otherEquipment.style.display = e.target.checked ? 'block' : 'none';
                        if (e.target.checked) {
                            otherEquipment.focus();
                        }
                    }
                }
            });
        });

        // Export handling
        const generateExportBtn = document.getElementById('generate-export');
        if (generateExportBtn) {
            generateExportBtn.addEventListener('click', () => {
                this.handleExport();
            });
        }

        // Export format radio buttons
        const exportRadios = document.querySelectorAll('input[name="export-format"]');
        exportRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.updateExportOptions(e.target.value);
                }
            });
        });

        // CSV import handlers
        const previewImportBtn = document.getElementById('preview-import');
        if (previewImportBtn) {
            previewImportBtn.addEventListener('click', () => {
                this.handlePreviewCSVImport();
            });
        }

        const confirmCSVBtn = document.getElementById('confirm-import');
        if (confirmCSVBtn) {
            confirmCSVBtn.addEventListener('click', () => {
                this.handleConfirmCSVImport();
            });
        }

        const cancelCSVBtn = document.getElementById('cancel-import');
        if (cancelCSVBtn) {
            cancelCSVBtn.addEventListener('click', () => {
                this.hideCSVPreview();
            });
        }

        // JSON import handlers
        const previewJSONBtn = document.getElementById('preview-json-import');
        if (previewJSONBtn) {
            previewJSONBtn.addEventListener('click', () => {
                this.handlePreviewJSONImport();
            });
        }

        const confirmJSONBtn = document.getElementById('confirm-json-import');
        if (confirmJSONBtn) {
            confirmJSONBtn.addEventListener('click', () => {
                this.handleConfirmJSONImport();
            });
        }

        const cancelJSONBtn = document.getElementById('cancel-json-import');
        if (cancelJSONBtn) {
            cancelJSONBtn.addEventListener('click', () => {
                this.hideJSONPreview();
            });
        }

        // Logbook actions
        const clearLogbookBtn = document.getElementById('clear-logbook');
        if (clearLogbookBtn) {
            clearLogbookBtn.addEventListener('click', () => {
                this.clearObservations();
            });
        }

        const downloadTemplateBtn = document.getElementById('download-template');
        if (downloadTemplateBtn) {
            downloadTemplateBtn.addEventListener('click', () => {
                this.downloadCSVTemplate();
            });
        }

        const importLogbookBtn = document.getElementById('import-logbook');
        if (importLogbookBtn) {
            importLogbookBtn.addEventListener('click', () => {
                this.switchTab('export');
                setTimeout(() => {
                    const csvImportBtn = document.getElementById('csv-import');
                    if (csvImportBtn) csvImportBtn.click();
                }, 100);
            });
        }

        // Batch selection
        const enableBatchSelection = document.getElementById('enable-batch-selection');
        if (enableBatchSelection) {
            enableBatchSelection.addEventListener('change', (e) => {
                this.toggleBatchSelection(e.target.checked);
            });
        }

        const selectAllBtn = document.getElementById('select-all-btn');
        if (selectAllBtn) {
            selectAllBtn.addEventListener('click', () => {
                this.selectAllObservations();
            });
        }

        const deselectAllBtn = document.getElementById('deselect-all-btn');
        if (deselectAllBtn) {
            deselectAllBtn.addEventListener('click', () => {
                this.deselectAllObservations();
            });
        }

        const applyBatchBtn = document.getElementById('apply-batch-selection');
        if (applyBatchBtn) {
            applyBatchBtn.addEventListener('click', () => {
                this.applyBatchSelection();
            });
        }

        // File input change handlers
        const csvImport = document.getElementById('csv-import');
        if (csvImport) {
            csvImport.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const MAX_FILE_SIZE = 10 * 1024 * 1024;
                    if (file.size > MAX_FILE_SIZE) {
                        this.showStatus(`File too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB`, 'error', 'export');
                        e.target.value = '';
                        return;
                    }
                    this.hideCSVPreview();
                    this.csvPreviewData = null;
                }
            });
        }

        const jsonImport = document.getElementById('json-import');
        if (jsonImport) {
            jsonImport.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const MAX_FILE_SIZE = 10 * 1024 * 1024;
                    if (file.size > MAX_FILE_SIZE) {
                        this.showStatus(`File too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB`, 'error', 'export');
                        e.target.value = '';
                        return;
                    }
                    this.hideJSONPreview();
                    this.jsonPreviewData = null;
                }
            });
        }

        // Form input tracking
        const recordPanel = document.getElementById('record-panel');
        if (recordPanel) {
            recordPanel.querySelectorAll('input, textarea, select').forEach(input => {
                input.addEventListener('input', () => {
                    const recordStatus = document.getElementById('record-status');
                    if (recordStatus) recordStatus.style.display = 'none';
                });
            });
        }

        // Touch event handling for mobile
        document.addEventListener('touchstart', function() {}, { passive: true });
    },

    // Handle CSV preview
    handlePreviewCSVImport() {
        const fileInput = document.getElementById('csv-import');
        if (!fileInput) {
            this.showStatus('CSV import input not found', 'error', 'export');
            return;
        }
        
        const file = fileInput.files[0];
        
        if (!file) {
            this.showStatus('Please select a CSV file', 'error', 'export');
            return;
        }

        const MAX_FILE_SIZE = 10 * 1024 * 1024;
        if (file.size > MAX_FILE_SIZE) {
            this.showStatus(`File too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB`, 'error', 'export');
            fileInput.value = '';
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const previewBtn = document.getElementById('preview-import');
                const originalText = previewBtn ? previewBtn.innerHTML : 'Preview Import';
                if (previewBtn) {
                    previewBtn.innerHTML = '<span class="loading"></span> Validating...';
                    previewBtn.disabled = true;
                }

                console.log('Starting CSV validation...');
                const validationResult = this.validateAndParseCSV(e.target.result);
                this.csvPreviewData = validationResult;
                
                console.log('Validation result:', {
                    totalRows: validationResult.totalRows,
                    validRows: validationResult.validRows,
                    invalidRows: validationResult.invalidRows,
                    warnings: validationResult.warnings.length,
                    errors: validationResult.errors.length
                });
                
                this.showCSVPreview(validationResult);
                
                if (previewBtn) {
                    previewBtn.innerHTML = originalText;
                    previewBtn.disabled = false;
                }

                if (validationResult.errors.length > 0 || validationResult.warnings.length > 0) {
                    this.showStatus(`Validation completed with ${validationResult.errors.length} errors and ${validationResult.warnings.length} warnings`, 
                                  validationResult.errors.length > 0 ? 'warning' : 'info', 'export');
                } else {
                    this.showStatus('CSV file validated successfully! Ready for import.', 'success', 'export');
                }

            } catch (error) {
                console.error('Preview error details:', error);
                const previewBtn = document.getElementById('preview-import');
                if (previewBtn) {
                    previewBtn.innerHTML = 'üëÅÔ∏è Preview Import';
                    previewBtn.disabled = false;
                }
                this.showStatus(`Validation failed: ${error.message}`, 'error', 'export');
                console.error('Validation error:', error);
            }
        };

        reader.onerror = () => {
            const previewBtn = document.getElementById('preview-import');
            if (previewBtn) {
                previewBtn.innerHTML = 'üëÅÔ∏è Preview Import';
                previewBtn.disabled = false;
            }
            this.showStatus('Error reading file. Please try again.', 'error', 'export');
        };

        reader.readAsText(file, 'UTF-8');
    },

    // Show CSV preview
    showCSVPreview(validationResult) {
        const previewSection = document.getElementById('csv-preview-section');
        const statsDiv = document.getElementById('validation-stats');
        const summaryDiv = document.getElementById('validation-summary');
        const previewTable = document.getElementById('csv-preview-table');
        
        if (!previewSection) {
            console.error('CSV preview section not found');
            return;
        }
        
        summaryDiv.innerHTML = '';
        if (previewTable) previewTable.innerHTML = '';
        
        if (statsDiv) {
            const validCountEl = document.getElementById('valid-count');
            const invalidCountEl = document.getElementById('invalid-count');
            const warningCountEl = document.getElementById('warning-count');
            const skippedCountEl = document.getElementById('skipped-count');
            const metadataCountEl = document.getElementById('metadata-count');
            
            if (validCountEl) validCountEl.textContent = `${validationResult.validRows}`;
            if (invalidCountEl) invalidCountEl.textContent = `${validationResult.invalidRows}`;
            if (warningCountEl) warningCountEl.textContent = `${validationResult.warningRows}`;
            if (skippedCountEl) skippedCountEl.textContent = `${validationResult.skippedRows}`;
            if (metadataCountEl) metadataCountEl.textContent = `${validationResult.metadataRows}`;
            
            statsDiv.style.display = 'flex';
        }
        
        let summaryHTML = `<div class="status-${validationResult.errors.length > 0 ? 'error' : validationResult.warnings.length > 0 ? 'warning' : 'success'} validation-summary">`;
        summaryHTML += `<strong>Validation Summary:</strong> ${validationResult.summary}`;
        
        if (validationResult.skippedRows > 0) {
            summaryHTML += `<div class="validation-info">`;
            summaryHTML += `<strong>üìÑ Header Detection:</strong> Found headers at row ${validationResult.headerRowIndex + 1}, skipped ${validationResult.skippedRows} row${validationResult.skippedRows > 1 ? 's' : ''} as metadata`;
            summaryHTML += `</div>`;
        }
        
        if (validationResult.errors.length > 0) {
            summaryHTML += '<div class="validation-errors">';
            summaryHTML += '<strong>‚ùå Critical Errors (must be fixed):</strong>';
            const errorCount = Math.min(validationResult.errors.length, 5);
            for (let i = 0; i < errorCount; i++) {
                summaryHTML += `<div class="validation-error">${validationResult.errors[i]}</div>`;
            }
            if (validationResult.errors.length > 5) {
                summaryHTML += `<div class="validation-error">... and ${validationResult.errors.length - 5} more errors</div>`;
            }
            summaryHTML += '</div>';
        }
        
        if (validationResult.warnings.length > 0) {
            summaryHTML += '<div class="validation-warnings">';
            summaryHTML += '<strong>‚ö†Ô∏è Warnings (should be reviewed):</strong>';
            const warningCount = Math.min(validationResult.warnings.length, 5);
            for (let i = 0; i < warningCount; i++) {
                summaryHTML += `<div class="validation-warning">${validationResult.warnings[i]}</div>`;
            }
            if (validationResult.warnings.length > 5) {
                summaryHTML += `<div class="validation-warning">... and ${validationResult.warnings.length - 5} more warnings</div>`;
            }
            summaryHTML += '</div>';
        }
        
        const sampleObs = validationResult.rows[0];
        if (sampleObs && sampleObs.data) {
            summaryHTML += '<div class="sample-preview">';
            summaryHTML += '<strong>üìã Sample Observation:</strong><br>';
            summaryHTML += `<code>${this.escapeHtml(sampleObs.data.scientificName)} - ${new Date(sampleObs.data.timestamp).toLocaleDateString()}`;
            if (sampleObs.data.photo) {
                summaryHTML += ' (with photo)';
            }
            summaryHTML += '</code>';
            summaryHTML += '</div>';
        }
        
        summaryHTML += '</div>';
        if (summaryDiv) summaryDiv.innerHTML = summaryHTML;
        
        const miniMapContainer = document.getElementById('mini-map-container');
        if (validationResult.hasCoordinates && validationResult.coordinates.length > 0 && miniMapContainer) {
            this.showMiniMap(validationResult.coordinates);
            miniMapContainer.style.display = 'block';
        } else if (miniMapContainer) {
            miniMapContainer.style.display = 'none';
        }
        
        if (previewTable) {
            const maxPreviewRows = 10;
            const rowsToShow = validationResult.rows.slice(0, maxPreviewRows);
            
            if (rowsToShow.length > 0 && rowsToShow[0].data) {
                let tableHTML = '<thead><tr>';
                validationResult.headers.forEach(header => {
                    const REQUIRED_CSV_HEADERS = [
                        'Observer Name', 'Scientific Name', 'Location', 'Habitat', 'Observation Type'
                    ];
                    const isRequired = REQUIRED_CSV_HEADERS.includes(header);
                    tableHTML += `<th scope="col">${header}${isRequired ? ' <span class="required-asterisk">*</span>' : ''}</th>`;
                });
                tableHTML += '<th scope="col">Status</th></tr></thead><tbody>';
                
                rowsToShow.forEach((row, rowIndex) => {
                    let rowClass = '';
                    let status = '';
                    let statusIcon = '';
                    
                    if (row.errors.length > 0) {
                        rowClass = 'error-row';
                        statusIcon = '‚ùå';
                        status = `${row.errors.length} error(s)`;
                    } else if (row.warnings.length > 0) {
                        rowClass = 'warning-row';
                        statusIcon = '‚ö†Ô∏è';
                        status = `${row.warnings.length} warning(s)`;
                    } else {
                        rowClass = 'valid-row';
                        statusIcon = '‚úÖ';
                        status = 'Valid';
                    }
                    
                    if (row.data && row.data['_coordinateStatus']) {
                        status += ` | ${row.data['_coordinateStatus']}`;
                    }
                    
                    tableHTML += `<tr class="${rowClass}" title="Original row ${row.originalLineNumber}">`;
                    
                    validationResult.headers.forEach(header => {
                        let value = row.data ? row.data[header] || '' : '';
                        let displayValue = value;
                        
                        if (value.length > 30) {
                            displayValue = value.substring(0, 30) + '...';
                        }
                        
                        displayValue = this.escapeHtml(displayValue);
                        const title = value.length > 30 ? this.escapeHtml(value) : '';
                        
                        tableHTML += `<td title="${title}">${displayValue}</td>`;
                    });
                    
                    tableHTML += `<td><span class="status-icon">${statusIcon}</span> ${status}</td></tr>`;
                });
                
                if (validationResult.rows.length > maxPreviewRows) {
                    tableHTML += `<tr><td colspan="${validationResult.headers.length + 1}" style="text-align: center; font-style: italic; padding: 1rem;">
                        ... and ${validationResult.rows.length - maxPreviewRows} more rows
                    </td></tr>`;
                }
                
                tableHTML += '</tbody>';
                previewTable.innerHTML = tableHTML;
            } else if (rowsToShow.length > 0) {
                previewTable.innerHTML = `
                    <tr class="error-row">
                        <td colspan="${validationResult.headers.length + 1}" style="text-align: center; padding: 2rem;">
                            <strong>No valid data to display</strong><br>
                            <small>All rows contain critical errors</small>
                        </td>
                    </tr>
                `;
            }
        }
        
        previewSection.style.display = 'block';
        previewSection.scrollIntoView({ behavior: 'smooth' });
        
        setTimeout(() => {
            const firstButton = previewSection.querySelector('button');
            if (firstButton) firstButton.focus();
        }, 100);
    },

    // Handle CSV import confirmation
    handleConfirmCSVImport() {
        if (!this.csvPreviewData) {
            this.showStatus('No CSV data to import', 'error', 'export');
            return;
        }

        const mode = document.getElementById('import-mode')?.value || 'append';
        
        if (mode === 'replace' && this.observations.length > 0) {
            if (!confirm('WARNING: This will replace ALL existing observations with the imported data. Are you sure?')) {
                return;
            }
        }

        try {
            const confirmBtn = document.getElementById('confirm-import');
            const originalText = confirmBtn ? confirmBtn.innerHTML : 'Confirm Import';
            if (confirmBtn) {
                confirmBtn.innerHTML = '<span class="loading"></span> Importing...';
                confirmBtn.disabled = true;
            }

            console.log(`Starting import in ${mode} mode...`);
            this.importObservationsFromCSV(this.csvPreviewData, mode)
                .then(result => {
                    if (confirmBtn) {
                        confirmBtn.innerHTML = originalText;
                        confirmBtn.disabled = false;
                    }
                    
                    const csvImport = document.getElementById('csv-import');
                    if (csvImport) csvImport.value = '';
                    this.hideCSVPreview();

                    let message = `CSV import successful!<br>`;
                    message += `‚Ä¢ ${result.imported} observations imported<br>`;
                    
                    if (result.updated > 0) {
                        message += `‚Ä¢ ${result.updated} observations updated<br>`;
                    }
                    
                    if (result.duplicates > 0) {
                        message += `‚Ä¢ ${result.duplicates} duplicates skipped<br>`;
                    }
                    
                    if (result.errors > 0) {
                        message += `‚Ä¢ ${result.errors} rows had errors<br>`;
                    }
                    
                    message += `‚Ä¢ Total observations: ${result.total}`;
                    
                    this.showStatus(message, 'success', 'export');

                    setTimeout(() => this.switchTab('logbook'), 2000);
                })
                .catch(error => {
                    console.error('Import error:', error);
                    if (confirmBtn) {
                        confirmBtn.innerHTML = '‚úÖ Confirm Import';
                        confirmBtn.disabled = false;
                    }
                    this.showStatus(`Import failed: ${error.message}`, 'error', 'export');
                });

        } catch (error) {
            console.error('Import error:', error);
            const confirmBtn = document.getElementById('confirm-import');
            if (confirmBtn) {
                confirmBtn.innerHTML = '‚úÖ Confirm Import';
                confirmBtn.disabled = false;
            }
            this.showStatus(`Import failed: ${error.message}`, 'error', 'export');
        }
    },

    // Handle JSON preview
    handlePreviewJSONImport() {
        const fileInput = document.getElementById('json-import');
        if (!fileInput) {
            this.showStatus('JSON import input not found', 'error', 'export');
            return;
        }
        
        const file = fileInput.files[0];
        
        if (!file) {
            this.showStatus('Please select a JSON file', 'error', 'export');
            return;
        }

        const MAX_FILE_SIZE = 10 * 1024 * 1024;
        if (file.size > MAX_FILE_SIZE) {
            this.showStatus(`File too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB`, 'error', 'export');
            fileInput.value = '';
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const previewBtn = document.getElementById('preview-json-import');
                const originalText = previewBtn ? previewBtn.innerHTML : 'Preview JSON Import';
                if (previewBtn) {
                    previewBtn.innerHTML = '<span class="loading"></span> Validating...';
                    previewBtn.disabled = true;
                }

                let jsonData;
                try {
                    jsonData = JSON.parse(e.target.result);
                } catch (parseError) {
                    throw new Error(`Invalid JSON format: ${parseError.message}`);
                }

                const validationResult = this.validateJSONData(jsonData);
                this.jsonPreviewData = validationResult;
                
                this.showJSONPreview(validationResult);
                
                if (previewBtn) {
                    previewBtn.innerHTML = originalText;
                    previewBtn.disabled = false;
                }

                if (validationResult.errors.length > 0 || validationResult.warnings.length > 0) {
                    this.showStatus(`Validation completed with ${validationResult.errors.length} errors and ${validationResult.warnings.length} warnings`, 
                                  validationResult.errors.length > 0 ? 'warning' : 'info', 'export');
                } else {
                    this.showStatus('JSON file validated successfully! Ready for import.', 'success', 'export');
                }

            } catch (error) {
                console.error('Preview error details:', error);
                const previewBtn = document.getElementById('preview-json-import');
                if (previewBtn) {
                    previewBtn.innerHTML = 'üëÅÔ∏è Preview JSON Import';
                    previewBtn.disabled = false;
                }
                this.showStatus(`Validation failed: ${error.message}`, 'error', 'export');
            }
        };

        reader.onerror = () => {
            const previewBtn = document.getElementById('preview-json-import');
            if (previewBtn) {
                previewBtn.innerHTML = 'üëÅÔ∏è Preview JSON Import';
                previewBtn.disabled = false;
            }
            this.showStatus('Error reading file. Please try again.', 'error', 'export');
        };

        reader.readAsText(file, 'UTF-8');
    },

    // Show JSON preview
    showJSONPreview(validationResult) {
        const previewSection = document.getElementById('json-preview-section');
        const statsDiv = document.getElementById('json-validation-stats');
        const summaryDiv = document.getElementById('json-validation-summary');
        const previewContent = document.getElementById('json-preview-content');
        
        if (!previewSection) {
            console.error('JSON preview section not found');
            return;
        }
        
        summaryDiv.innerHTML = '';
        previewContent.innerHTML = '';
        
        if (statsDiv) {
            const validCountEl = document.getElementById('json-valid-count-val');
            const invalidCountEl = document.getElementById('json-invalid-count-val');
            const photoCountEl = document.getElementById('json-photo-count-val');
            
            const photoCount = validationResult.observations.filter(obs => 
                obs.data.photo && obs.data.photo.data
            ).length;
            
            if (validCountEl) validCountEl.textContent = `${validationResult.validCount}`;
            if (invalidCountEl) invalidCountEl.textContent = `${validationResult.invalidCount}`;
            if (photoCountEl) photoCountEl.textContent = `${photoCount}`;
            
            statsDiv.style.display = 'flex';
        }
        
        let summaryHTML = `<div class="status-${validationResult.errors.length > 0 ? 'error' : validationResult.warnings.length > 0 ? 'warning' : 'success'} validation-summary">`;
        summaryHTML += `<strong>Validation Summary:</strong> ${validationResult.summary}`;
        
        if (validationResult.errors.length > 0) {
            summaryHTML += '<div class="validation-errors">';
            summaryHTML += '<strong>‚ùå Errors:</strong>';
            validationResult.errors.slice(0, 5).forEach(error => {
                summaryHTML += `<div class="validation-error">${error}</div>`;
            });
            if (validationResult.errors.length > 5) {
                summaryHTML += `<div class="validation-error">... and ${validationResult.errors.length - 5} more</div>`;
            }
            summaryHTML += '</div>';
        }
        
        if (validationResult.warnings.length > 0) {
            summaryHTML += '<div class="validation-warnings">';
            summaryHTML += '<strong>‚ö†Ô∏è Warnings:</strong>';
            validationResult.warnings.slice(0, 5).forEach(warning => {
                summaryHTML += `<div class="validation-warning">${warning}</div>`;
            });
            if (validationResult.warnings.length > 5) {
                summaryHTML += `<div class="validation-warning">... and ${validationResult.warnings.length - 5} more</div>`;
            }
            summaryHTML += '</div>';
        }
        
        const sampleObs = validationResult.observations[0];
        if (sampleObs && sampleObs.data) {
            summaryHTML += '<div class="sample-preview">';
            summaryHTML += '<strong>üìã Sample Observation:</strong><br>';
            summaryHTML += `<code>${this.escapeHtml(sampleObs.data.scientificName)} - ${new Date(sampleObs.data.timestamp).toLocaleDateString()}`;
            if (sampleObs.data.photo) {
                summaryHTML += ' (with photo)';
            }
            summaryHTML += '</code>';
            summaryHTML += '</div>';
        }
        
        summaryHTML += '</div>';
        if (summaryDiv) summaryDiv.innerHTML = summaryHTML;
        
        if (previewContent && validationResult.observations.length > 0) {
            const sampleData = validationResult.observations[0].data;
            const previewData = {
                id: sampleData.id,
                timestamp: sampleData.timestamp,
                scientificName: sampleData.scientificName,
                observerName: sampleData.observerName,
                location: sampleData.location
            };
            
            previewContent.textContent = JSON.stringify(previewData, null, 2);
        }
        
        previewSection.style.display = 'block';
        previewSection.scrollIntoView({ behavior: 'smooth' });
        
        setTimeout(() => {
            const firstButton = previewSection.querySelector('button');
            if (firstButton) firstButton.focus();
        }, 100);
    },

    // Handle JSON import confirmation
    handleConfirmJSONImport() {
        if (!this.jsonPreviewData) {
            this.showStatus('No JSON data to import', 'error', 'export');
            return;
        }

        const modeElement = document.getElementById('json-import-mode');
        const mode = modeElement ? modeElement.value : 'append';
        
        if (mode === 'replace' && this.observations.length > 0) {
            if (!confirm('WARNING: This will replace ALL existing observations with the imported data. Are you sure?')) {
                return;
            }
        }

        try {
            const confirmBtn = document.getElementById('confirm-json-import');
            const originalText = confirmBtn ? confirmBtn.innerHTML : 'Confirm Import';
            if (confirmBtn) {
                confirmBtn.innerHTML = '<span class="loading"></span> Importing...';
                confirmBtn.disabled = true;
            }

            const result = this.importObservationsFromJSON(this.jsonPreviewData, mode);
            
            if (confirmBtn) {
                confirmBtn.innerHTML = originalText;
                confirmBtn.disabled = false;
            }
            
            const jsonImport = document.getElementById('json-import');
            if (jsonImport) jsonImport.value = '';
            this.hideJSONPreview();

            let message = `JSON import successful!<br>`;
            message += `‚Ä¢ ${result.imported} observations imported<br>`;
            
            if (result.hasPhotos) {
                message += `‚Ä¢ Includes photos<br>`;
            }
            
            if (result.updated > 0) {
                message += `‚Ä¢ ${result.updated} observations updated<br>`;
            }
            
            if (result.duplicates > 0) {
                message += `‚Ä¢ ${result.duplicates} duplicates skipped<br>`;
            }
            
            if (result.errors > 0) {
                message += `‚Ä¢ ${result.errors} observations had errors<br>`;
            }
            
            message += `‚Ä¢ Total observations: ${result.total}`;

            this.showStatus(message, 'success', 'export');
            setTimeout(() => this.switchTab('logbook'), 1500);

        } catch (error) {
            console.error('Import error:', error);
            const confirmBtn = document.getElementById('confirm-json-import');
            if (confirmBtn) {
                confirmBtn.innerHTML = '‚úÖ Confirm Import';
                confirmBtn.disabled = false;
            }
            this.showStatus(`Import failed: ${error.message}`, 'error', 'export');
        }
    },

    // Handle export generation
    handleExport() {
        const pdfRadio = document.getElementById('export-pdf');
        const csvRadio = document.getElementById('export-csv');
        const jsonRadio = document.getElementById('export-json');
        
        let format = 'csv';
        if (pdfRadio && pdfRadio.checked) {
            format = 'pdf';
        } else if (csvRadio && csvRadio.checked) {
            format = 'csv';
        } else if (jsonRadio && jsonRadio.checked) {
            format = 'json';
        }
        
        const dateFrom = document.getElementById('date-from')?.value || null;
        const dateTo = document.getElementById('date-to')?.value || null;
        const enableBatch = document.getElementById('enable-batch-selection')?.checked || false;
        
        const selectedIds = enableBatch && this.selectedObservations.size > 0 ? this.selectedObservations : null;
        
        const filteredObservations = this.getFilteredObservations(dateFrom, dateTo, selectedIds);
        
        if (filteredObservations.length === 0) {
            this.showStatus('No observations found for the selected criteria', 'error', 'export');
            return;
        }
        
        switch (format) {
            case 'csv':
                this.exportToCSV(filteredObservations, dateFrom, dateTo, selectedIds);
                break;
            case 'json':
                this.exportToJSON(filteredObservations, dateFrom, dateTo, selectedIds);
                break;
            case 'pdf':
                this.exportToPDF(filteredObservations, dateFrom, dateTo, selectedIds);
                break;
            default:
                this.showStatus('Please select an export format', 'error', 'export');
        }
    },

    // Update export options
    updateExportOptions(format) {
        const csvNote = document.getElementById('csv-export-note');
        const jsonNote = document.getElementById('json-export-note');
        const pdfNote = document.getElementById('pdf-export-note');
        
        if (csvNote) csvNote.style.display = format === 'csv' ? 'block' : 'none';
        if (jsonNote) jsonNote.style.display = format === 'json' ? 'block' : 'none';
        if (pdfNote) pdfNote.style.display = format === 'pdf' ? 'block' : 'none';
    },

    // Hide CSV preview
    hideCSVPreview() {
        const previewSection = document.getElementById('csv-preview-section');
        const statsDiv = document.getElementById('validation-stats');
        const csvImport = document.getElementById('csv-import');
        
        if (previewSection) previewSection.style.display = 'none';
        if (statsDiv) statsDiv.style.display = 'none';
        if (csvImport) csvImport.value = '';
        this.csvPreviewData = null;
        
        const progressUI = document.getElementById('csv-import-progress');
        if (progressUI) progressUI.style.display = 'none';
        
        if (this.miniMap) {
            try {
                this.miniMap.remove();
            } catch (e) {
                console.warn('Error removing mini map:', e);
            }
            this.miniMap = null;
        }
        const miniMapContainer = document.getElementById('mini-map-container');
        if (miniMapContainer) {
            miniMapContainer.innerHTML = '';
            miniMapContainer.style.display = 'none';
        }
    },

    // Hide JSON preview
    hideJSONPreview() {
        const previewSection = document.getElementById('json-preview-section');
        const statsDiv = document.getElementById('json-validation-stats');
        const jsonImport = document.getElementById('json-import');
        
        if (previewSection) previewSection.style.display = 'none';
        if (statsDiv) statsDiv.style.display = 'none';
        if (jsonImport) jsonImport.value = '';
        this.jsonPreviewData = null;
    },

    // Download CSV template
    downloadCSVTemplate() {
        const headers = [
            'ID', 'Timestamp', 'Observer Name', 'Scientific Name', 'Common Name', 'Location',
            'Latitude', 'Longitude', 'Habitat', 'Observation Type',
            'Characteristics', 'Equipment', 'References', 'Notes', 'Has Photo'
        ];
        
        const exampleRows = [
            [
                'ECO-20231225-ABC12',
                '2023-12-25T14:30:00',
                'Jane Doe',
                'Canis lupus',
                'Gray Wolf',
                'Yellowstone National Park, Wyoming',
                '44.4280',
                '-110.5885',
                'forest',
                'direct',
                'Large adult, gray coat, observed hunting elk herd',
                'binoculars; camera',
                'Field Guide to North American Mammals, 4th Edition',
                'Observed from approximately 100m distance using 10x42 binoculars. Appeared healthy.',
                'Yes'
            ],
            [
                'ECO-20231226-XYZ34',
                '2023-12-26T09:15:00',
                'John Smith',
                'Ursus arctos horribilis',
                'Grizzly Bear',
                'Glacier National Park, Montana',
                '48.7596',
                '-113.7870',
                'alpine',
                'track',
                'Large paw print, approximately 12 inches wide',
                'camera; measuring tape',
                'Bear Tracks Identification Guide',
                'Found near creek bed. Photo taken for documentation.',
                'Yes'
            ]
        ];
        
        let csvContent = '';
        
        csvContent += '# EcoLens Import Template\n';
        csvContent += '# Created: ' + new Date().toISOString() + '\n';
        csvContent += '# Required fields: Observer Name, Scientific Name, Location, Habitat, Observation Type\n\n';
        
        csvContent += headers.join(',') + '\n';
        
        exampleRows.forEach(row => {
            csvContent += row.map(field => {
                return this.escapeCSV(field);
            }).join(',') + '\n';
        });
        
        csvContent += '\n';
        csvContent += '# INSTRUCTIONS:\n';
        csvContent += '# 1. Keep the header row exactly as shown\n';
        csvContent += '# 2. Fill in data below the header row\n';
        csvContent += '# 3. For Equipment field, separate multiple items with semicolons (;)\n';
        csvContent += '# 4. For coordinates, use decimal degrees (e.g., 44.4280, -110.5885)\n';
        csvContent += '# 5. For dates, use ISO format: YYYY-MM-DDTHH:MM:SS\n';
        csvContent += '# 6. Text starting with =, +, -, @ will be automatically protected\n';
        
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        this.downloadFile(url, 'EcoLens_Import_Template.csv');
        
        this.showStatus('CSV template downloaded successfully', 'success', 'logbook');
    },

    // Toggle batch selection UI
    toggleBatchSelection(show) {
        const batchSection = document.getElementById('batch-selection');
        if (batchSection) {
            if (show) {
                batchSection.style.display = 'block';
                this.renderBatchCheckboxes();
            } else {
                batchSection.style.display = 'none';
                this.selectedObservations.clear();
            }
        }
    },

    // Render batch selection checkboxes
    renderBatchCheckboxes() {
        const container = document.getElementById('batch-checkboxes');
        if (!container) return;
        
        container.innerHTML = '';
        
        if (this.observations.length === 0) {
            container.innerHTML = '<div class="empty-message">No observations available for selection</div>';
            return;
        }
        
        this.observations.forEach(obs => {
            const date = new Date(obs.timestamp).toLocaleDateString();
            const div = document.createElement('div');
            div.className = 'batch-checkbox-item';
            div.innerHTML = `
                <input type="checkbox" id="batch-${obs.id}" value="${obs.id}" 
                       ${this.selectedObservations.has(obs.id) ? 'checked' : ''}
                       aria-label="Select observation ${obs.id} - ${this.escapeHtml(obs.scientificName)}">
                <label for="batch-${obs.id}">
                    <span class="batch-checkbox-id">${obs.id}</span>
                    <span class="batch-checkbox-info">
                        ${date} - ${this.escapeHtml(obs.scientificName)}
                        ${obs.commonName ? ` (${this.escapeHtml(obs.commonName)})` : ''}
                    </span>
                </label>
            `;
            container.appendChild(div);
            
            const checkbox = div.querySelector('input');
            checkbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    this.selectedObservations.add(obs.id);
                } else {
                    this.selectedObservations.delete(obs.id);
                }
                this.updateBatchSelectionCount();
            });
        });
        
        this.updateBatchSelectionCount();
    },

    // Update batch selection count
    updateBatchSelectionCount() {
        const countElement = document.getElementById('batch-selection-count');
        if (countElement) {
            countElement.textContent = `${this.selectedObservations.size}`;
        }
    },

    // Select all observations
    selectAllObservations() {
        this.observations.forEach(obs => {
            this.selectedObservations.add(obs.id);
        });
        this.renderBatchCheckboxes();
    },

    // Deselect all observations
    deselectAllObservations() {
        this.selectedObservations.clear();
        this.renderBatchCheckboxes();
    },

    // Apply batch selection
    applyBatchSelection() {
        const batchSection = document.getElementById('batch-selection');
        if (batchSection) {
            batchSection.style.display = 'none';
        }
        this.showStatus(`${this.selectedObservations.size} observations selected for export`, 'info', 'export');
    },

    // Switch between tabs
    switchTab(tabName) {
        document.querySelectorAll('.tab-btn').forEach(btn => {
            const isActive = btn.dataset.tab === tabName;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-selected', isActive);
        });

        document.querySelectorAll('.tab-panel').forEach(panel => {
            const isActive = panel.id === `${tabName}-panel`;
            panel.classList.toggle('active', isActive);
            if (isActive) {
                panel.setAttribute('tabindex', '0');
            } else {
                panel.setAttribute('tabindex', '-1');
            }
        });

        const exportDownload = document.getElementById('export-download');
        const pdfProgress = document.getElementById('pdf-progress');
        
        if (exportDownload) exportDownload.style.display = 'none';
        if (pdfProgress) pdfProgress.style.display = 'none';
        
        if (tabName !== 'export') {
            this.hideCSVPreview();
            this.hideJSONPreview();
        }
        
        if (tabName === 'logbook') {
            this.renderLogbook();
        }
        
        if (window.innerWidth < 768) {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        const tabPanel = document.getElementById(`${tabName}-panel`);
        if (tabPanel) {
            setTimeout(() => {
                tabPanel.focus();
            }, 100);
        }
    },

    // Handle recording a new observation
    handleRecordObservation() {
        // Quick storage check
        try {
            if (this.observations.length > 0) {
                const testData = JSON.stringify(this.observations.slice(0, 1));
                if (testData.length > 1000000) { // If first observation is >1MB
                    this.showStatus('Warning: Observations are very large. Consider removing photos before saving more.', 'warning');
                }
            }
        } catch (e) {
            // Ignore check errors
        }
        
        const date = document.getElementById('observation-date')?.value;
        const time = document.getElementById('observation-time')?.value;
        const observerName = document.getElementById('observer-name')?.value.trim();
        const scientificName = document.getElementById('scientific-name')?.value.trim();
        const commonName = document.getElementById('common-name')?.value.trim();
        const location = document.getElementById('location')?.value.trim();
        const habitat = document.getElementById('habitat')?.value;
        const observationType = document.getElementById('observation-type')?.value;
        const characteristics = document.getElementById('characteristics')?.value.trim();
        const notes = document.getElementById('notes')?.value.trim();
        const references = document.getElementById('references')?.value.trim();

        const equipment = [];
        document.querySelectorAll('input[name="equipment"]:checked').forEach(cb => {
            equipment.push(cb.value);
        });
        
        const otherEquipmentInput = document.getElementById('other-equipment');
        const otherEquipment = otherEquipmentInput ? otherEquipmentInput.value.trim() : '';
        if (otherEquipment && equipment.includes('other-equipment')) {
            equipment[equipment.indexOf('other-equipment')] = `other: ${otherEquipment}`;
        }

        const errors = [];
        if (!date || !time) {
            errors.push('Observation date and time');
        }
        if (!observerName) {
            errors.push('Observer name');
            const observerNameInput = document.getElementById('observer-name');
            if (observerNameInput) observerNameInput.focus();
        }
        if (!scientificName) {
            errors.push('Scientific name');
            if (!observerName) {
                const scientificNameInput = document.getElementById('scientific-name');
                if (scientificNameInput) scientificNameInput.focus();
            }
        }
        if (!location && !this.mapMarker) {
            errors.push('Location');
        }
        if (!habitat) {
            errors.push('Habitat type');
        }
        if (!observationType) {
            errors.push('Observation type');
        }

        if (errors.length > 0) {
            this.showStatus(`Please fill in required fields: ${errors.join(', ')}`, 'error');
            return;
        }

        let coordinates = null;
        let accuracy = null;
        if (this.mapMarker) {
            const latlng = this.mapMarker.getLatLng();
            coordinates = { lat: latlng.lat, lng: latlng.lng };
            accuracy = this.mapMarker.options.accuracy || null;
        }

        const observation = this.createObservation({
            date,
            time,
            observerName,
            scientificName,
            commonName,
            location: location || 'Map location selected',
            coordinates,
            accuracy,
            habitat,
            observationType,
            characteristics,
            notes,
            equipment,
            references,
            photo: this.currentPhoto
        });

        if (this.saveObservation(observation)) {
            // Show success with observation ID
            this.showStatus(`‚úì Observation ${observation.id} saved successfully!`, 'success');
            
            // Reset form after a brief delay
            setTimeout(() => {
                this.resetForm();
                // Optional: Switch to logbook tab
                // this.switchTab('logbook');
            }, 1500);
        } else {
            this.showStatus('Failed to save observation. Please check your data.', 'error');
        }
    },

    // Reset the form
    resetForm() {
        this.setCurrentDateTime();
        
        const observerName = document.getElementById('observer-name');
        const scientificName = document.getElementById('scientific-name');
        const commonName = document.getElementById('common-name');
        const location = document.getElementById('location');
        const habitat = document.getElementById('habitat');
        const observationType = document.getElementById('observation-type');
        const characteristics = document.getElementById('characteristics');
        const notes = document.getElementById('notes');
        const references = document.getElementById('references');
        const otherEquipment = document.getElementById('other-equipment');
        
        if (observerName) observerName.value = '';
        if (scientificName) scientificName.value = '';
        if (commonName) commonName.value = '';
        if (location) location.value = '';
        if (habitat) habitat.value = '';
        if (observationType) observationType.value = '';
        if (characteristics) characteristics.value = '';
        if (notes) notes.value = '';
        if (references) references.value = '';
        
        document.querySelectorAll('input[name="equipment"]').forEach(cb => {
            cb.checked = false;
        });
        
        if (otherEquipment) {
            otherEquipment.style.display = 'none';
            otherEquipment.value = '';
        }
        
        this.removePhoto();
        
        if (this.mapMarker && this.map) {
            this.map.removeLayer(this.mapMarker);
            this.mapMarker = null;
        }
        
        if (this.mapEnabled) {
            this.toggleMap(false);
        }
        
        const locationStatus = document.getElementById('location-status');
        if (locationStatus) locationStatus.style.display = 'none';
        
        const recordBtn = document.getElementById('record-btn');
        if (recordBtn && recordBtn.dataset.editingId) {
            recordBtn.innerHTML = '<i class="fas fa-save"></i> Record Observation';
            recordBtn.onclick = () => this.handleRecordObservation();
            delete recordBtn.dataset.editingId;
        }
        
        if (observerName) observerName.focus();
    },

// Remove photo - SIMPLIFIED
removePhoto() {
    console.log('Removing photo');
    
    // Clear photo data
    this.currentPhoto = null;
    
    // Hide preview
    const preview = document.getElementById('photo-preview');
    if (preview) {
        preview.style.display = 'none';
        preview.src = '';
        // Clean up any event listeners
        preview.onload = null;
        preview.onerror = null;
    }
    
    // Hide remove button
    const removeBtn = document.getElementById('photo-remove');
    if (removeBtn) {
        removeBtn.style.display = 'none';
    }
    
    // Hide info
    const photoInfo = document.getElementById('photo-info');
    if (photoInfo) {
        photoInfo.style.display = 'none';
    }
    
    // Reset file input
    const fileInput = document.getElementById('photo-upload');
    if (fileInput) {
        fileInput.value = '';
    }
    
    // Show feedback
    this.showStatus('Photo removed', 'success');
},

    // Toggle map visibility
    toggleMap(show = null) {
        const mapContainer = document.getElementById('map-container');
        const toggleBtn = document.getElementById('toggle-map');
        const toggleText = document.getElementById('map-toggle-text');
        
        if (!mapContainer || !toggleBtn || !toggleText) return;
        
        this.mapEnabled = show !== null ? show : !this.mapEnabled;
        
        if (this.mapEnabled) {
            mapContainer.style.display = 'block';
            toggleText.textContent = 'Hide Map';
            toggleBtn.setAttribute('aria-expanded', 'true');
            
            if (!this.map) {
                this.initMap();
            } else {
                setTimeout(() => {
                    try {
                        this.map.invalidateSize();
                    } catch (error) {
                        console.error('Error invalidating map size:', error);
                        this.map = null;
                        this.initMap();
                    }
                }, 100);
            }
        } else {
            mapContainer.style.display = 'none';
            toggleText.textContent = 'Show Map';
            toggleBtn.setAttribute('aria-expanded', 'false');
        }
    },

    // Initialize Leaflet map - FIXED for dark mode
    initMap() {
        const mapElement = document.getElementById('map');
        if (!mapElement || typeof L === 'undefined') {
            console.error('Map element or Leaflet not available');
            const mapContainer = document.getElementById('map-container');
            if (mapContainer) {
                mapContainer.innerHTML = '<div class="status-message status-error">Map library not loaded. Please refresh the page.</div>';
            }
            return;
        }
        
        try {
            // Clean up existing map
            if (this.map) {
                try {
                    this.map.remove();
                } catch (e) {
                    console.warn('Error removing previous map:', e);
                }
                this.map = null;
            }
            
            // Create new map
            const defaultCenter = [-35.2809, 149.1300];
            this.map = L.map('map', {
                center: defaultCenter,
                zoom: 13,
                preferCanvas: true, // Better performance
                attributionControl: false // We'll add our own
            });
            
            // Add tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19,
                detectRetina: true
            }).addTo(this.map);
            
            // Add custom attribution
            L.control.attribution({
                position: 'bottomright',
                prefix: false
            }).addAttribution('¬© OpenStreetMap').addTo(this.map);
            
            // Add scale control
            L.control.scale({ 
                imperial: false,
                position: 'bottomleft'
            }).addTo(this.map);
            
            // Handle map clicks
            this.map.on('click', (e) => {
                this.addMarker(e.latlng);
            });
            
            // Handle map resize for dark mode
            this.map.on('load', () => {
                setTimeout(() => {
                    this.map.invalidateSize();
                }, 100);
            });
            
            console.log('Map initialized successfully');
            
        } catch (error) {
            console.error('Error initializing map:', error);
            const mapContainer = document.getElementById('map-container');
            if (mapContainer) {
                mapContainer.innerHTML = `<div class="status-message status-error">
                    <i class="fas fa-exclamation-triangle"></i> Error loading map: ${error.message}
                    <br><small>Please refresh the page or check your internet connection</small>
                </div>`;
            }
        }
    },

    // Add marker to map
    addMarker(latlng, accuracy = null) {
        if (!this.map || typeof L === 'undefined') {
            console.error('Map or Leaflet not initialized');
            return;
        }
        
        if (!latlng.lat || !latlng.lng) {
            if (Array.isArray(latlng)) {
                latlng = L.latLng(latlng[0], latlng[1]);
            } else {
                console.error('Invalid latlng format:', latlng);
                return;
            }
        }
        
        if (this.mapMarker) {
            this.map.removeLayer(this.mapMarker);
            if (this.accuracyCircle) {
                this.map.removeLayer(this.accuracyCircle);
            }
        }
        
        this.mapMarker = L.marker(latlng, {
            draggable: true,
            title: 'Observation Location',
            alt: 'Map marker for observation location'
        }).addTo(this.map);
        
        this.mapMarker.on('dragend', (e) => {
            const marker = e.target;
            const position = marker.getLatLng();
            const lat = position.lat.toFixed(6);
            const lng = position.lng.toFixed(6);
            const locationInput = document.getElementById('location');
            if (locationInput) locationInput.value = `Lat: ${lat}, Lng: ${lng}`;
        });
        
        this.mapMarker.options.accuracy = accuracy;
        
        if (accuracy) {
            this.accuracyCircle = L.circle(latlng, {
                radius: accuracy,
                color: '#3498db',
                fillColor: '#3498db',
                fillOpacity: 0.1,
                weight: 1
            }).addTo(this.map);
        }
        
        const lat = latlng.lat.toFixed(6);
        const lng = latlng.lng.toFixed(6);
        const locationInput = document.getElementById('location');
        if (locationInput) locationInput.value = `Lat: ${lat}, Lng: ${lng}`;
        
        try {
            this.map.setView(latlng, Math.max(this.map.getZoom(), 15));
        } catch (error) {
            console.error('Error setting map view:', error);
        }
    },

    // Get user's current location
    getUserLocation() {
        if (!navigator.geolocation) {
            this.showLocationStatus('Geolocation is not supported by your browser', 'error');
            return;
        }

        if (this.isLocating) {
            this.showLocationStatus('Already getting location...', 'info');
            return;
        }

        this.isLocating = true;
        const locateBtn = document.getElementById('use-my-location');
        const originalHTML = locateBtn ? locateBtn.innerHTML : '<i class="fas fa-map-marker-alt"></i> Use My Location';
        if (locateBtn) {
            locateBtn.innerHTML = '<span class="loading"></span> Locating...';
            locateBtn.disabled = true;
        }

        this.showLocationStatus('Getting your location...', 'info');

        const timeoutId = setTimeout(() => {
            if (this.isLocating) {
                this.showLocationStatus('Location request is taking longer than expected. Please ensure location services are enabled.', 'warning');
            }
        }, 30000);

        navigator.geolocation.getCurrentPosition(
            (position) => {
                clearTimeout(timeoutId);
                
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy;
                
                console.log('Location acquired:', { lat, lng, accuracy });
                
                if (!this.map) {
                    this.initMap();
                }
                
                if (!this.mapEnabled) {
                    this.toggleMap(true);
                }
                
                setTimeout(() => {
                    if (!this.map) {
                        console.error('Map not initialized');
                        this.showLocationStatus('Map initialization failed', 'error');
                        this.isLocating = false;
                        if (locateBtn) {
                            locateBtn.innerHTML = originalHTML;
                            locateBtn.disabled = false;
                        }
                        return;
                    }
                    
                    const latlng = L.latLng(lat, lng);
                    
                    this.addMarker(latlng, accuracy);
                    
                    const accuracyMsg = accuracy ? ` (accuracy: ¬±${Math.round(accuracy)}m)` : '';
                    this.showLocationStatus(`Location acquired${accuracyMsg}`, 'success');
                    
                    const latFormatted = lat.toFixed(6);
                    const lngFormatted = lng.toFixed(6);
                    const locationInput = document.getElementById('location');
                    if (locationInput) locationInput.value = `Lat: ${latFormatted}, Lng: ${lngFormatted}`;
                    
                    try {
                        this.map.setView(latlng, 15, {
                            animate: true,
                            duration: 1
                        });
                    } catch (error) {
                        console.error('Error setting map view:', error);
                    }
                    
                    this.isLocating = false;
                    if (locateBtn) {
                        locateBtn.innerHTML = originalHTML;
                        locateBtn.disabled = false;
                    }
                }, 100);
            },
            (error) => {
                clearTimeout(timeoutId);
                console.error('Geolocation error:', error);
                let message = 'Unable to get your location';
                
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        message = 'Location permission denied. Please enable location services for this site in your browser settings.';
                        if (window.confirm('Location permission denied. Would you like to see instructions on how to enable location permissions?')) {
                            window.open('https://support.google.com/chrome/answer/142065?hl=en', '_blank');
                        }
                        break;
                    case error.POSITION_UNAVAILABLE:
                        message = 'Location information unavailable. Please check your device location settings.';
                        break;
                    case error.TIMEOUT:
                        message = 'Location request timed out. Please try again.';
                        break;
                    default:
                        message = 'An unknown error occurred while getting location.';
                }
                
                this.showLocationStatus(message, 'error');
                this.isLocating = false;
                if (locateBtn) {
                    locateBtn.innerHTML = originalHTML;
                    locateBtn.disabled = false;
                }
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    },

    // Handle photo upload - REPLACE THE ENTIRE FUNCTION WITH THIS
    async handlePhotoUpload(event) {
        const file = event.target.files[0];
        if (!file) {
            this.showStatus('No file selected', 'error');
            return;
        }

        // Validate file type
        if (!file.type.startsWith('image/')) {
            this.showStatus('Please select an image file (JPEG, PNG, etc.)', 'error');
            event.target.value = '';
            return;
        }

        // Validate file size (5MB limit)
        const MAX_SIZE = 5 * 1024 * 1024; // 5MB
        if (file.size > MAX_SIZE) {
            this.showStatus(`Image must be less than ${MAX_SIZE / 1024 / 1024}MB`, 'error');
            event.target.value = '';
            return;
        }

        // Show loading state
        const captureBtn = document.getElementById('capture-photo');
        const originalText = captureBtn ? captureBtn.innerHTML : '';
        if (captureBtn) {
            captureBtn.innerHTML = '<span class="loading"></span> Processing...';
            captureBtn.disabled = true;
        }

        // Show compression status
        this.showStatus('Compressing photo...', 'info');

        const reader = new FileReader();
        
        reader.onload = async (e) => {
            try {
                const dataUrl = e.target.result;
                
                // Validate data URL format
                if (!dataUrl || !dataUrl.startsWith('data:image/')) {
                    this.showStatus('Invalid image format', 'error');
                    if (captureBtn) {
                        captureBtn.innerHTML = originalText;
                        captureBtn.disabled = false;
                    }
                    return;
                }
                
                // Compress the photo
                const compressed = await this.compressPhoto(dataUrl, {
                    maxWidth: 1600,
                    maxHeight: 1600,
                    quality: 0.7,
                    mimeType: 'image/jpeg'
                });
                
                // Create thumbnail for UI
                const thumbnail = await this.createThumbnail(dataUrl, 200);
                
                // Store the photo data with both full and thumbnail versions
                this.currentPhoto = {
                    fullData: compressed.data,           // For PDF export
                    thumbnailData: thumbnail.data,       // For UI display
                    filename: `ECO_${Date.now()}.jpg`,
                    type: 'image/jpeg',
                    metadata: {
                        width: compressed.width,
                        height: compressed.height,
                        originalSize: file.size,
                        compressedSize: compressed.compressedSize,
                        compressionRatio: compressed.compressionRatio,
                        timestamp: new Date().toISOString()
                    }
                };
                
                // Update the preview with thumbnail
                this.updatePhotoPreview(thumbnail.data, captureBtn, originalText);
                
                // Show compression result
                this.showStatus(`Photo compressed: ${compressed.compressionRatio}% smaller`, 'success');
                
            } catch (error) {
                console.error('Photo compression failed:', error);
                this.showStatus('Photo processing failed, using original', 'warning');
                
                // Fallback to original
                const dataUrl = e.target.result;
                this.currentPhoto = {
                    fullData: dataUrl,
                    thumbnailData: dataUrl,
                    filename: `ECO_${Date.now()}.jpg`,
                    type: 'image/jpeg',
                    metadata: {
                        originalSize: file.size,
                        compressedSize: file.size,
                        compressionRatio: 0,
                        timestamp: new Date().toISOString()
                    }
                };
                
                this.updatePhotoPreview(dataUrl, captureBtn, originalText);
            }
        };
        
        reader.onerror = () => {
            this.showStatus('Error reading file', 'error');
            event.target.value = '';
            if (captureBtn) {
                captureBtn.innerHTML = originalText;
                captureBtn.disabled = false;
            }
        };
        
        reader.readAsDataURL(file);
    },

// Safe compression that always returns an image
compressImageSafe(dataUrl, callback) {
    try {
        const img = new Image();
        
        img.onload = () => {
            try {
                // Create canvas and compress
                const canvas = document.createElement('canvas');
                const maxWidth = 1920;
                const maxHeight = 1080;
                let width = img.width;
                let height = img.height;
                
                // Resize if too large
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width = Math.floor(width * ratio);
                    height = Math.floor(height * ratio);
                }
                
                canvas.width = width;
                canvas.height = height;
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);
                ctx.drawImage(img, 0, 0, width, height);
                
                // Get compressed image
                const compressedData = canvas.toDataURL('image/jpeg', 0.7);
                
                // Clean up
                img.src = '';
                canvas.width = 0;
                canvas.height = 0;
                
                callback(compressedData);
            } catch (error) {
                console.warn('Compression failed, using original:', error);
                callback(dataUrl); // Fall back to original
            }
        };
        
        img.onerror = () => {
            console.warn('Image load failed, using original data URL');
            callback(dataUrl); // Fall back to original
        };
        
        img.src = dataUrl;
        
        // Timeout fallback
        setTimeout(() => {
            if (img.src) {
                console.warn('Image compression timeout, using original');
                callback(dataUrl);
            }
        }, 5000);
        
    } catch (error) {
        console.error('Compression error:', error);
        callback(dataUrl); // Always return something
    }
},

// Update photo preview
updatePhotoPreview(imageData, captureBtn, originalText) {
    const preview = document.getElementById('photo-preview');
    if (!preview) {
        // No preview element, just restore button
        if (captureBtn) {
            captureBtn.innerHTML = originalText;
            captureBtn.disabled = false;
        }
        this.showStatus('Photo added successfully', 'success');
        return;
    }
    
    // Set the image source
    preview.src = imageData;
    preview.style.display = 'block';
    preview.alt = 'Observation photo preview';
    
    // Handle image load
    const handleLoad = () => {
        // Update photo info
        const photoInfo = document.getElementById('photo-info');
        const photoSize = document.getElementById('photo-size');
        const photoResolution = document.getElementById('photo-resolution');
        const photoRemove = document.getElementById('photo-remove');
        
        if (photoSize && this.currentPhoto) {
            const size = this.currentPhoto.metadata ? 
                this.formatBytes(this.currentPhoto.metadata.compressedSize) : 
                this.formatBytes(this.currentPhoto.data.length * 3/4);
            
            const ratio = this.currentPhoto.metadata ? 
                ` (${this.currentPhoto.metadata.compressionRatio}% smaller)` : '';
            
            photoSize.innerHTML = `<i class="fas fa-weight-hanging" aria-hidden="true"></i> Size: ${size}${ratio}`;
        }
        if (photoResolution) {
            const width = preview.naturalWidth || preview.width || 0;
            const height = preview.naturalHeight || preview.height || 0;
            photoResolution.innerHTML = `<i class="fas fa-expand-alt" aria-hidden="true"></i> Resolution: ${width}√ó${height}`;
        }
        if (photoInfo) {
            photoInfo.style.display = 'block';
        }
        if (photoRemove) {
            photoRemove.style.display = 'flex';
        }
        
        // Restore button
        if (captureBtn) {
            captureBtn.innerHTML = originalText;
            captureBtn.disabled = false;
        }
        
        // Show success
        this.showStatus('Photo added successfully', 'success');
        
        // Clean up event listeners
        preview.removeEventListener('load', handleLoad);
        preview.removeEventListener('error', handleError);
    };
    
    const handleError = () => {
        console.error('Preview image failed to load');
        this.showStatus('Failed to load image preview', 'error');
        this.removePhoto();
        if (captureBtn) {
            captureBtn.innerHTML = originalText;
            captureBtn.disabled = false;
        }
        
        // Clean up event listeners
        preview.removeEventListener('load', handleLoad);
        preview.removeEventListener('error', handleError);
    };
    
    // Check if already loaded
    if (preview.complete && preview.naturalWidth > 0) {
        handleLoad();
    } else {
        // Wait for load or error
        preview.addEventListener('load', handleLoad);
        preview.addEventListener('error', handleError);
        
        // Timeout fallback
        setTimeout(() => {
            if (!preview.complete) {
                console.warn('Image preview loading timeout');
                preview.removeEventListener('load', handleLoad);
                preview.removeEventListener('error', handleError);
                handleLoad(); // Still try to proceed
            }
        }, 3000);
    }
},

    // Compress image
    compressImage(dataUrl, callback, maxWidth = 1920, maxHeight = 1080, quality = 0.7) {
        const img = new Image();
        
        // Set crossOrigin to anonymous to avoid CORS issues
        img.crossOrigin = 'anonymous';
        
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                let width = img.width;
                let height = img.height;

                // Calculate new dimensions while maintaining aspect ratio
                if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width = Math.floor(width * ratio);
                    height = Math.floor(height * ratio);
                }

                // Validate dimensions
                if (width <= 0 || height <= 0) {
                    console.error('Invalid image dimensions after scaling');
                    callback(dataUrl); // Return original if scaling fails
                    return;
                }

                canvas.width = width;
                canvas.height = height;

                const ctx = canvas.getContext('2d');
                
                // Draw white background first
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);
                
                // Draw the image
                ctx.drawImage(img, 0, 0, width, height);

                try {
                    // Try JPEG compression first, fall back to PNG
                    let compressedDataUrl;
                    try {
                        compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    } catch (e) {
                        console.warn('JPEG compression failed, using PNG');
                        compressedDataUrl = canvas.toDataURL('image/png');
                    }
                    
                    // Clean up
                    img.src = '';
                    canvas.width = 0;
                    canvas.height = 0;
                    
                    // Add to cleanup list
                    this.canvasCleanupList.push(canvas);
                    
                    // Limit cleanup list size
                    if (this.canvasCleanupList.length > 10) {
                        const oldCanvas = this.canvasCleanupList.shift();
                        if (oldCanvas) {
                            oldCanvas.width = 0;
                            canvas.height = 0;
                        }
                    }
                    
                    callback(compressedDataUrl);
                    
                } catch (canvasError) {
                    console.error('Canvas compression error:', canvasError);
                    callback(dataUrl); // Return original on error
                }
                
            } catch (error) {
                console.error('Error in image compression:', error);
                callback(dataUrl); // Return original on error
            }
        };
        
        img.onerror = () => {
            console.error('Error loading image for compression, using original');
            img.src = '';
            callback(dataUrl); // Return original data URL
        };
        
        // Add a timeout to prevent hanging
        const timeoutId = setTimeout(() => {
            if (img.src) {
                console.warn('Image loading timeout, using original');
                img.src = '';
                callback(dataUrl);
            }
        }, 5000);
        
        const originalOnLoad = img.onload;
        img.onload = function() {
            clearTimeout(timeoutId);
            if (originalOnLoad) originalOnLoad.call(this);
        };
        
        const originalOnError = img.onerror;
        img.onerror = function() {
            clearTimeout(timeoutId);
            if (originalOnError) originalOnError.call(this);
        };
        
        img.src = dataUrl;
    },

    // Clean up canvas elements
    cleanupCanvasElements() {
        console.log('Cleaning up canvas elements...');
        
        // Clean up any canvas elements we created
        this.canvasCleanupList.forEach(canvas => {
            try {
                if (canvas && canvas.parentNode) {
                    canvas.parentNode.removeChild(canvas);
                }
            } catch (e) {
                console.warn('Error cleaning up canvas:', e);
            }
        });
        
        this.canvasCleanupList = [];
        
        // Also clean up any other canvas elements
        document.querySelectorAll('canvas.temp-canvas').forEach(canvas => {
            try {
                if (canvas.parentNode) {
                    canvas.parentNode.removeChild(canvas);
                }
            } catch (e) {
                console.warn('Error removing temp canvas:', e);
            }
        });
    },

    // Format bytes
    formatBytes(bytes, decimals = 1) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    },

    // Render logbook entries
    renderLogbook() {
        const container = document.getElementById('logbook-entries');
        const emptyMessage = document.getElementById('empty-logbook');
        const observationCount = document.getElementById('observation-count');
        
        if (!container) return;
        
        if (observationCount) {
            observationCount.textContent = `${this.observations.length} observation${this.observations.length !== 1 ? 's' : ''}`;
        }
        
        if (this.observations.length === 0) {
            container.innerHTML = '';
            if (emptyMessage) emptyMessage.style.display = 'block';
            return;
        }
        
        if (emptyMessage) emptyMessage.style.display = 'none';
        
        const entriesHtml = this.observations.map(obs => `
            <div class="log-entry" data-id="${obs.id}" role="listitem" tabindex="0">
                <div class="log-header">
                    <div class="log-id">${obs.id}</div>
                    <div class="log-date"><i class="far fa-calendar" aria-hidden="true"></i> ${new Date(obs.timestamp).toLocaleString()}</div>
                </div>
                <div class="log-species">
                    <i class="fas fa-feather-alt" aria-hidden="true"></i> ${this.escapeHtml(obs.scientificName)}
                    ${obs.commonName ? `<span style="color: var(--medium-gray); font-weight: normal;"> (${this.escapeHtml(obs.commonName)})</span>` : ''}
                </div>
                <div class="log-location"><i class="fas fa-map-marker-alt" aria-hidden="true"></i> ${this.escapeHtml(obs.location.text)}</div>
                <div class="log-details" id="details-${obs.id}">
                    <div style="margin: 0.5rem 0;">
                        <strong><i class="fas fa-user" aria-hidden="true"></i> Observer:</strong> ${this.escapeHtml(obs.observerName)}
                    </div>
                    <div style="margin: 0.5rem 0;">
                        <strong><i class="fas fa-binoculars" aria-hidden="true"></i> Observation Type:</strong> ${this.formatObservationType(obs.observationType)}
                    </div>
                    <div style="margin: 0.5rem 0;">
                        <strong><i class="fas fa-tree" aria-hidden="true"></i> Habitat:</strong> ${this.capitalizeFirst(obs.habitat)}
                    </div>
                    ${obs.characteristics ? `
                        <div style="margin: 0.5rem 0;">
                            <strong><i class="fas fa-clipboard-list" aria-hidden="true"></i> Characteristics:</strong> ${this.escapeHtml(obs.characteristics)}
                        </div>
                    ` : ''}
                    ${obs.equipment && obs.equipment.length > 0 ? `
                        <div style="margin: 0.5rem 0;">
                            <strong><i class="fas fa-tools" aria-hidden="true"></i> Equipment:</strong> ${obs.equipment.map(eq => this.formatEquipment(eq)).join(', ')}
                        </div>
                    ` : ''}
                    ${obs.notes ? `
                        <div style="margin: 0.5rem 0;">
                            <strong><i class="fas fa-sticky-note" aria-hidden="true"></i> Notes:</strong> ${this.escapeHtml(obs.notes)}
                        </div>
                    ` : ''}
                    ${obs.references ? `
                        <div style="margin: 0.5rem 0;">
                            <strong><i class="fas fa-book-open" aria-hidden="true"></i> References:</strong> ${this.escapeHtml(obs.references)}
                        </div>
                    ` : ''}
                    ${obs.photo ? `
                        <div style="margin: 0.5rem 0;">
                            <strong><i class="fas fa-camera" aria-hidden="true"></i> Photo:</strong> Included
                        </div>
                    ` : ''}
                    <div class="log-actions">
                        <button class="btn btn-outline btn-small edit-btn" data-id="${obs.id}" aria-label="Edit observation ${obs.id}">
                            <i class="fas fa-edit" aria-hidden="true"></i> Edit
                        </button>
                        <button class="btn btn-danger btn-small delete-btn" data-id="${obs.id}" aria-label="Delete observation ${obs.id}">
                            <i class="fas fa-trash" aria-hidden="true"></i> Delete
                        </button>
                    </div>
                </div>
            </div>
        `).join('');
        
        container.innerHTML = entriesHtml;
        
        this.attachLogbookEventListeners();
    },

    // Attach event listeners to logbook entries
    attachLogbookEventListeners() {
        document.querySelectorAll('.log-entry').forEach(entry => {
            entry.addEventListener('click', (e) => {
                if (!e.target.classList.contains('edit-btn') && 
                    !e.target.classList.contains('delete-btn') &&
                    !e.target.closest('.log-actions')) {
                    const id = entry.dataset.id;
                    const details = document.getElementById(`details-${id}`);
                    if (details) {
                        const isExpanded = details.classList.toggle('show');
                        entry.setAttribute('aria-expanded', isExpanded);
                    }
                }
            });
            
            entry.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    const id = entry.dataset.id;
                    const details = document.getElementById(`details-${id}`);
                    if (details) {
                        const isExpanded = details.classList.toggle('show');
                        entry.setAttribute('aria-expanded', isExpanded);
                    }
                }
            });
        });
        
        document.querySelectorAll('.edit-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.editObservation(btn.dataset.id);
            });
        });
        
        document.querySelectorAll('.delete-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteObservation(btn.dataset.id);
            });
        });
    },

    // Edit an observation
    editObservation(id) {
        const observation = this.observations.find(obs => obs.id === id);
        if (!observation) return;

        const dateTime = new Date(observation.timestamp);
        const dateStr = dateTime.toISOString().split('T')[0];
        const timeStr = dateTime.toTimeString().slice(0, 5);

        const dateInput = document.getElementById('observation-date');
        const timeInput = document.getElementById('observation-time');
        const observerNameInput = document.getElementById('observer-name');
        const scientificNameInput = document.getElementById('scientific-name');
        const commonNameInput = document.getElementById('common-name');
        const locationInput = document.getElementById('location');
        const habitatInput = document.getElementById('habitat');
        const observationTypeInput = document.getElementById('observation-type');
        const characteristicsInput = document.getElementById('characteristics');
        const notesInput = document.getElementById('notes');
        const referencesInput = document.getElementById('references');
        const otherEquipmentInput = document.getElementById('other-equipment');
        
        if (dateInput) dateInput.value = dateStr;
        if (timeInput) timeInput.value = timeStr;
        if (observerNameInput) observerNameInput.value = observation.observerName;
        if (scientificNameInput) scientificNameInput.value = observation.scientificName;
        if (commonNameInput) commonNameInput.value = observation.commonName;
        if (locationInput) locationInput.value = observation.location.text;
        if (habitatInput) habitatInput.value = observation.habitat;
        if (observationTypeInput) observationTypeInput.value = observation.observationType;
        if (characteristicsInput) characteristicsInput.value = observation.characteristics;
        if (notesInput) notesInput.value = observation.notes;
        if (referencesInput) referencesInput.value = observation.references;

        document.querySelectorAll('input[name="equipment"]').forEach(cb => {
            cb.checked = false;
            if (observation.equipment) {
                const eqValue = cb.value;
                observation.equipment.forEach(eq => {
                    if (eq.startsWith('other:') && eqValue === 'other-equipment') {
                        cb.checked = true;
                        if (otherEquipmentInput) {
                            otherEquipmentInput.value = eq.substring(6);
                            otherEquipmentInput.style.display = 'block';
                        }
                    } else if (eq === eqValue) {
                        cb.checked = true;
                    }
                });
            }
        });

        // Clear current photo first
        this.currentPhoto = null;
        const photoPreview = document.getElementById('photo-preview');
        const photoRemove = document.getElementById('photo-remove');
        const photoInfo = document.getElementById('photo-info');
        
        if (photoPreview) {
            photoPreview.style.display = 'none';
            photoPreview.src = '';
        }
        if (photoRemove) photoRemove.style.display = 'none';
        if (photoInfo) photoInfo.style.display = 'none';

        if (observation.photo) {
            this.currentPhoto = observation.photo;
            const preview = document.getElementById('photo-preview');
            if (preview) {
                preview.src = observation.photo.data;
                preview.style.display = 'block';
                preview.alt = 'Observation photo preview';
            }
            
            const photoRemove = document.getElementById('photo-remove');
            if (photoRemove) {
                photoRemove.style.display = 'flex';
            }
            
            const photoInfo = document.getElementById('photo-info');
            const photoSize = document.getElementById('photo-size');
            if (photoSize) photoSize.textContent = `Size: ${this.formatBytes(observation.photo.compressedSize || observation.photo.data.length * 3/4)}`;
            if (photoInfo) photoInfo.style.display = 'block';
        }

        const recordBtn = document.getElementById('record-btn');
        if (recordBtn) {
            recordBtn.innerHTML = '<i class="fas fa-save"></i> Update Observation';
            recordBtn.dataset.editingId = id;
            recordBtn.onclick = () => this.handleUpdateObservation(id);
        }
        
        this.switchTab('record');
        if (observerNameInput) observerNameInput.focus();
    },

    // Handle updating an observation
    handleUpdateObservation(id) {
        const date = document.getElementById('observation-date')?.value;
        const time = document.getElementById('observation-time')?.value;
        const observerName = document.getElementById('observer-name')?.value.trim();
        const scientificName = document.getElementById('scientific-name')?.value.trim();
        const commonName = document.getElementById('common-name')?.value.trim();
        const location = document.getElementById('location')?.value.trim();
        const habitat = document.getElementById('habitat')?.value;
        const observationType = document.getElementById('observation-type')?.value;
        const characteristics = document.getElementById('characteristics')?.value.trim();
        const notes = document.getElementById('notes')?.value.trim();
        const references = document.getElementById('references')?.value.trim();

        const equipment = [];
        document.querySelectorAll('input[name="equipment"]:checked').forEach(cb => {
            equipment.push(cb.value);
        });
        
        const otherEquipmentInput = document.getElementById('other-equipment');
        const otherEquipment = otherEquipmentInput ? otherEquipmentInput.value.trim() : '';
        if (otherEquipment && equipment.includes('other-equipment')) {
            equipment[equipment.indexOf('other-equipment')] = `other: ${otherEquipment}`;
        }

        if (!date || !time || !observerName || !scientificName || !location || !habitat || !observationType) {
            this.showStatus('Please fill in all required fields', 'error');
            return;
        }

        const updatedData = {
            timestamp: new Date(date + 'T' + time).toISOString(),
            observerName,
            scientificName,
            commonName,
            location: {
                text: location,
                coordinates: this.observations.find(obs => obs.id === id)?.location.coordinates || null,
                accuracy: this.observations.find(obs => obs.id === id)?.location.accuracy || null
            },
            habitat,
            observationType,
            characteristics,
            notes,
            equipment,
            references,
            photo: this.currentPhoto
        };

        if (this.updateObservation(id, updatedData)) {
            this.showStatus('Observation updated successfully!', 'success');
            this.resetForm();
        }
    },

    // Show status message
    showStatus(message, type = 'info', panel = 'record') {
        const statusEl = document.getElementById(`${panel}-status`);
        if (!statusEl) {
            console.error(`Status element not found for panel: ${panel}`);
            return;
        }
        statusEl.innerHTML = message;
        statusEl.className = `status-message status-${type}`;
        statusEl.style.display = 'block';
        statusEl.setAttribute('role', 'alert');
        
        if (type === 'success') {
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }
    },

    // Show location status
    showLocationStatus(message, type = 'info') {
        const statusEl = document.getElementById('location-status');
        if (!statusEl) return;
        
        statusEl.textContent = message;
        statusEl.className = `status-message status-${type}`;
        statusEl.style.display = 'block';
        statusEl.setAttribute('role', 'status');
        
        if (type === 'error') {
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 5000);
        }
    },

    // Update date inputs
    updateDateInputs() {
        const today = new Date().toISOString().split('T')[0];
        const dateFrom = document.getElementById('date-from');
        const dateTo = document.getElementById('date-to');
        
        if (dateFrom) {
            dateFrom.value = today;
            dateFrom.max = today;
        }
        if (dateTo) {
            dateTo.value = today;
            dateTo.max = today;
        }
    },

    // Update CSV import progress
    updateCSVImportProgress(progress, currentRow, totalRows) {
        const progressBar = document.getElementById('csv-import-progress-bar');
        const statusText = document.getElementById('csv-import-status-text');
        const currentAction = document.getElementById('csv-import-current-action');
        
        if (progressBar) {
            progressBar.value = progress;
        }
        
        if (statusText) {
            statusText.textContent = `Processing row ${currentRow} of ${totalRows}`;
        }
        
        if (currentAction) {
            currentAction.textContent = `Row ${currentRow}`;
        }
    },

    // Show mini map
    showMiniMap(coordinates) {
        const container = document.getElementById('mini-map-container');
        if (!container) return;
        
        container.innerHTML = '';
        
        if (coordinates.length === 0) return;
        
        if (typeof L === 'undefined') {
            console.error('Leaflet not loaded. Cannot show mini map.');
            container.innerHTML = '<div class="status-message status-error" style="margin: 1rem 0;">Map library not loaded. Please refresh the page.</div>';
            return;
        }
        
        const validCoords = coordinates.filter(coord => 
            coord && coord.lat !== undefined && coord.lng !== undefined && 
            !isNaN(coord.lat) && !isNaN(coord.lng)
        );
        
        if (validCoords.length === 0) return;
        
        try {
            if (this.miniMap) {
                try {
                    this.miniMap.remove();
                } catch (e) {
                    console.warn('Error removing previous mini map:', e);
                }
            }
            
            this.miniMap = L.map(container).setView(validCoords[0], 5);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(this.miniMap);
            
            if (validCoords.length > 10) {
                const markers = L.markerClusterGroup();
                validCoords.forEach(coord => {
                    markers.addLayer(L.marker([coord.lat, coord.lng])
                        .bindPopup(`Lat: ${coord.lat.toFixed(5)}<br>Lng: ${coord.lng.toFixed(5)}`));
                });
                this.miniMap.addLayer(markers);
            } else {
                validCoords.forEach(coord => {
                    L.marker([coord.lat, coord.lng]).addTo(this.miniMap)
                        .bindPopup(`Lat: ${coord.lat.toFixed(5)}<br>Lng: ${coord.lng.toFixed(5)}`);
                });
            }
            
            if (validCoords.length > 1) {
                const bounds = validCoords.map(coord => [coord.lat, coord.lng]);
                this.miniMap.fitBounds(bounds, { padding: [20, 20] });
            }
            
            L.control.scale({ imperial: false }).addTo(this.miniMap);
            
        } catch (error) {
            console.error('Error creating mini map:', error);
            container.innerHTML = `<div class="status-message status-error" style="margin: 1rem 0;">
                Error creating map preview: ${error.message}
            </div>`;
        }
    },

    // Format observation type
    formatObservationType(type) {
        const typeMap = {
            'direct': 'Direct sighting',
            'scat': 'Scat/droppings',
            'track': 'Track/footprint',
            'call': 'Call/sound',
            'nest': 'Nest/den',
            'roadkill': 'Roadkill',
            'feather': 'Feather',
            'bone': 'Bone/skull',
            'other': 'Other evidence'
        };
        return typeMap[type] || this.capitalizeFirst(type);
    },

    // Format equipment
    formatEquipment(equipment) {
        const eqMap = {
            'binoculars': 'Binoculars',
            'camera': 'Camera',
            'hand-lens': 'Hand lens',
            'gps': 'GPS',
            'microscope': 'Microscope',
            'hair-tube': 'Hair tube',
            'pitfall-trap': 'Pitfall trap',
            'camera-trap': 'Camera trap',
            'other-equipment': 'Other'
        };
        
        if (equipment.startsWith('other: ')) {
            return equipment.substring(7);
        }
        
        return eqMap[equipment] || this.capitalizeFirst(equipment);
    },

    // Escape HTML
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },

    // Capitalize first letter
    capitalizeFirst(string) {
        return string ? string.charAt(0).toUpperCase() + string.slice(1) : '';
    },

    // Photo compression utility
    async compressPhoto(photoData, options = {}) {
        const {
            maxWidth = 1024,
            maxHeight = 1024,
            quality = 0.7,
            mimeType = 'image/jpeg'
        } = options;
        
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = function() {
                const canvas = document.createElement('canvas');
                let width = img.width;
                let height = img.height;
                
                // Calculate new dimensions while maintaining aspect ratio
                if (width > maxWidth) {
                    height = Math.round((height * maxWidth) / width);
                    width = maxWidth;
                }
                if (height > maxHeight) {
                    width = Math.round((width * maxHeight) / height);
                    height = maxHeight;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                try {
                    const compressedDataUrl = canvas.toDataURL(mimeType, quality);
                    resolve({
                        data: compressedDataUrl,
                        width: width,
                        height: height,
                        originalSize: photoData.length,
                        compressedSize: compressedDataUrl.length,
                        compressionRatio: Math.round((1 - (compressedDataUrl.length / photoData.length)) * 100)
                    });
                } catch (error) {
                    console.warn('Compression failed, using original:', error);
                    resolve({
                        data: photoData,
                        width: img.width,
                        height: img.height,
                        originalSize: photoData.length,
                        compressedSize: photoData.length,
                        compressionRatio: 0
                    });
                }
            };
            
            img.onerror = function() {
                console.warn('Image loading failed, using original');
                resolve({
                    data: photoData,
                    originalSize: photoData.length,
                    compressedSize: photoData.length,
                    compressionRatio: 0
                });
            };
            
            img.src = photoData;
        });
    }, // <-- THIS CLOSING BRACE AND COMMA WERE MISSING

    // Migrate existing observations to use compression
    async migrateExistingObservations() {
        console.log('Starting photo migration for existing observations...');
        
        for (let i = 0; i < this.observations.length; i++) {
            const obs = this.observations[i];
            
            if (obs.photo && obs.photo.data && !obs.photo.thumbnailData) {
                console.log(`Migrating photo for observation ${obs.id}...`);
                
                try {
                    const compressed = await this.compressPhoto(obs.photo.data, {
                        maxWidth: 1600,
                        maxHeight: 1600,
                        quality: 0.7
                    });
                    
                    const thumbnail = await this.createThumbnail(obs.photo.data, 200);
                    
                    this.observations[i].photo = {
                        ...obs.photo,
                        fullData: compressed.data,
                        thumbnailData: thumbnail.data,
                        metadata: {
                            width: compressed.width,
                            height: compressed.height,
                            originalSize: compressed.originalSize,
                            compressedSize: compressed.compressedSize,
                            compressionRatio: compressed.compressionRatio,
                            timestamp: obs.photo.metadata?.timestamp || new Date().toISOString()
                        }
                    };
                    
                    // Store full-res in IndexedDB
                    if (typeof indexedDB !== 'undefined') {
                        await this.storeFullResPhotoInIndexedDB(obs.id, this.observations[i].photo);
                    }
                    
                } catch (error) {
                    console.warn(`Migration failed for observation ${obs.id}:`, error);
                }
            }
        }
        
        // Save migrated data
        this.saveToLocalStorage();
        console.log('Photo migration complete');
        this.showStatus('Existing photos optimized for storage', 'success');
    },

    // Quick compression for thumbnails
    async createThumbnail(photoData, size = 200) {
        return this.compressPhoto(photoData, {
            maxWidth: size,
            maxHeight: size,
            quality: 0.5,
            mimeType: 'image/jpeg'
        });
    }
}; // <-- This is the closing brace for the EcoLens object

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    EcoLens.init();
});

// Add offline detection
window.addEventListener('online', () => {
    console.log('App is online');
    EcoLens.showStatus('You are back online', 'success');
});

window.addEventListener('offline', () => {
    console.log('App is offline - data saved locally');
    EcoLens.showStatus('You are offline. Observations are saved locally and will sync when online.', 'warning');
});

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    if (window.EcoLens) {
        EcoLens.cleanupMemory();
        
        if (EcoLens.memoryCleanupInterval) {
            clearInterval(EcoLens.memoryCleanupInterval);
        }
        
        document.querySelectorAll('a[href^="blob:"]').forEach(link => {
            URL.revokeObjectURL(link.href);
        });
    }
});
</script>
    <!-- Photo Processing Status - ADD THIS BEFORE </body> -->
    <div id="photo-processing-status" style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        display: none;
        font-size: 14px;
    ">
        <span id="compression-status"></span>
    </div>
</body>
</html>
